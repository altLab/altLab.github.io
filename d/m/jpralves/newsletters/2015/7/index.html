<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

		<!-- <base href="https://altlab.org/d/" />  -->
		<title>Newsletter altLab - 2015-06-16 - Nº 7 | altLab Documenta</title>
				<meta name="description" content="Newsletters altLab Nº 7 de 16 de Junho de 2015">
				<meta property="og:type" content="article" />
		<meta property="og:title" content="Newsletter altLab - 2015-06-16 - Nº 7 | altLab Documenta" />
		<meta property="og:description" content="Newsletters altLab Nº 7 de 16 de Junho de 2015" />
		<meta property="og:url" content="https://altlab.org/d/m/jpralves/newsletters/2015/7/" />
		<meta property="og:site_name" content="altLab Documenta" />

		<!-- Bootstrap -->
		<link href="../../../../../themes/altlab/css/bootstrap.min.css" rel="stylesheet">
		<link href="../../../../../themes/altlab/override-test.css" rel="stylesheet">
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="../../../../../themes/altlab/js/jquery-1.12.4.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="../../../../../themes/altlab/js/bootstrap.min.js"></script>

	</head>
	<body>
<div class="container">
<div class="container-fluid">
      <div class="page-header hidden-xs" id="brand-logo">
        <h1><a href="../../../../../../index.html"><img src="../../../../../themes/altlab/altlab-logo-gradoverwhite.png" width="180" height="120" alt="Home" style="vertical-align:text-bottom" /></a> Documenta <span class="glyphicon glyphicon-leaf" style="color:#98ff98; padding-left:5px; top:2.8px;"></span></h1>

      </div>
			<nav class="navbar navbar-inverse">

				<div class="container-fluid">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#myNavbar">
							<span class="sr-only">Toggle navigation</span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
<div class="visible-xs">
<a class="navbar-brand" href="../../../../../../index.html"><img src="../../../../../themes/altlab/altlab-logo-documenta.png" width="58" height="35" alt="Home" style="margin-top: -7px;"></a>
						<a class="navbar-brand" href="../../../../../index.html">Documenta <span class="glyphicon glyphicon-leaf" style="color:#98ff98; padding-left:5px; top:2.8px;"></span></a></div>
					</div>
					<div class="collapse navbar-collapse" id="myNavbar">
						<ul class="nav navbar-nav">

           	<li id="dropdown.1" class="dropdown">
		<a class= "dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Membros <span class="caret"></span></a>
  
    <ul class="dropdown-menu">
<li>
<a href="../../../../index.html">Index</a>
</li>
   
           	<li id="dropdown.101" class="dropdown">
		<a href="../../../index.html">João Alves <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.102" class="dropdown">
		<a href="../../../../sislog/index.html">Fernando Carvalho <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.103" class="dropdown">
		<a href="../../../../pangelo/index.html">Pedro Ângelo <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.104" class="dropdown">
		<a href="../../../../dinix/index.html">Dinix <span class="caret"></span></a>
  
      	</li>
            	<li>
		<a href="../../../../funke/funke.html">m/funke/funke</a>
  
   	</li>
            	<li id="dropdown.106" class="dropdown">
		<a href="../../../../afonsom/index.html">Afonso Muralha <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.107" class="dropdown">
		<a href="../../../../x3msnake/index.html">X3msnake <span class="caret"></span></a>
  
      	</li>
            	<li>
		<a href="../../../../ampmendes/index.html">António Mendes</a>
  
   	</li>
            	<li>
		<a href="../../../../guardajoao/index.html">GuardaJoao</a>
  
   	</li>
            	<li>
		<a href="../../../../jac/index.html">JAC</a>
  
   	</li>
            	<li>
		<a href="../../../../nini/index.html">Nuno Nini</a>
  
   	</li>
 
</ul>
    	</li>
            	<li id="dropdown.2" class="dropdown">
		<a class= "dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Documentação Partilhada <span class="caret"></span></a>
  
    <ul class="dropdown-menu">
<li>
<a href="../../../../../s/index.html">Index</a>
</li>
   
                         	<li id="dropdown.203" class="dropdown">
		<a href="../../../../../s/workshops/index.html">Workshops <span class="caret"></span></a>
  
      	</li>
                   	<li>
		<a href="../../../../../s/documenta/index.html">Documenta DevMap</a>
  
   	</li>
                   	<li>
		<a href="../../../../../s/processos/index.html">Processos do Lab (draft)</a>
  
   	</li>
            	<li id="dropdown.208" class="dropdown">
		<a href="../../../../../s/recursos/index.html">Recursos <span class="caret"></span></a>
  
      	</li>
 
</ul>
    	</li>
 
						</ul>
					</div>
				</div>
			</nav>

			<div class="container">
				<div class="container">
				<section id="content">
					<div class="inner">
						<h1 id="topo"><img src="../res/__Titulo.png" alt="Newsletter altLab" /></h1>

<p>2015-06-16 - Nº 7</p>

<div id="google_translate_element"></div>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'pt', layout: google.translate.TranslateElement.FloatPosition.TOP_LEFT, multilanguagePage: true}, 'google_translate_element');
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<h1>Editorial</h1>

<p>Nesta 7ª Newsletter continuamos a criar conteúdo para alimentar as mentes dos makers. Disponibilizamos todos os <em>sketchs</em> em ZIP para facilitar a sua utilização.</p>

<p>Esta Newsletter encontra-se mais uma vez disponível no sistema documenta do altLab.
Todas as Newsletters encontram-se indexadas no <a href="../../index.html">link</a>.</p>

<p>Esta Newsletter tem os seguintes tópicos:</p>

<ul>
<li><a href="#Novidades-da-Semana">Novidades da Semana</a></li>
<li><a href="#Ciencia-e-Tecnologia">Ciência e Tecnologia</a></li>
<li><a href="#Cursos-MOOC">Cursos MOOC</a></li>
<li><a href="#Modelos-3D">Modelos 3D</a></li>
<li><a href="#Open-Source">Open Source</a></li>
<li><a href="#Circuitos">Circuitos</a></li>
<li><a href="#Assunto-Geek">Assunto Geek</a></li>
<li><a href="#Artigo-do-Maker">Artigo do Maker</a></li>
<li><a href="#Compras">Compras</a></li>
</ul>

<p>Nesta Newsletter apresentamos uma rubrica nova - Assunto Geek - esta irá abordar um tópico que é considerado <em>geek</em> - nesta semana falamos de optimizações código em AVR.
São apresentados diversos circuitos para controlar LED de 7 Segmentos e LED de 8x8. A ferramenta Open Source da semana é o 7-Zip que é uma ferramenta para criar e ler ficheiros comprimidos em ZIP e 7Z entre outros. O projeto de maker é um cartão de visita com mensagens em LEDs.</p>

<p><img src="../res/_jpralves.jpg" alt="jpralves" /> João Alves (<a href="https://altlab.org/d/m/jpralves/newsletters/2015/7/&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x6a;&#112;&#114;&#x61;&#108;&#118;&#x65;&#x73;&#64;g&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;o&#x6d;#x6d;&a&i&l&t&o&:&j&p&r&a&l&v&e&s&@g&m&a&i&l&.&co&m"><span class="__cf_email__" data-cfemail="d3b9a3a1b2bfa5b6a093b4beb2babffdb0bcbe">[email&#160;protected]</span></a>)</p>

<p>O conteúdo da Newsletter encontra-se sob a licença <img src="../res/_by-nc-sa4.0.png" alt="by-nc-sa4.0" /> <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>

<hr />

<h1 id="Novidades-da-Semana">Novidades da Semana <a href="#topo">^</a></h1>

<ul>
<li><p><a href="https://hbr.org/2015/06/does-hardware-even-matter-anymore/">Does Hardware Even Matter Anymore?</a></p>

<p><img src="NS7_DoesHardwareEvenMatterAnymore.jpg" alt="NS7_DoesHardwareEvenMatterAnymore" /></p>

<p><em>"We are in the midst of a technological revolution that is every bit as profound as the impact of cheap computing power, but it’s subtler and harder to notice. It will ease the way for companies launching and updating digital products, but it presents steep new learning curves that companies will have to master if they are to be successful. What I’m referring to is the migration of functionality from hardware to software. In more and more businesses, physical objects are no longer the primary basis for innovation and differentiation. They come second to innovations in computer code."</em></p></li>
<li><p><a href="http://blogs.esa.int/rosetta/2015/06/14/rosettas-lander-philae-wakes-up-from-hibernation/">Rosetta’s lander Philae wakes up from hibernation</a></p>

<p><img src="NS7_RosettasLanderPhilaeWakesUpFro.jpg" alt="NS7_RosettasLanderPhilaeWakesUpFro" /></p>

<p><em>"Rosetta's lander Philae is out of hibernation! The signals were received at ESA's European Space Operations Centre in Darmstadt at 22:28 CEST on 13 June. More than 300 data packets have been analysed by the teams at the Lander Control Center at the German Aerospace Center (DLR)."</em></p></li>
</ul>

<hr />

<h1 id="Ciencia-e-Tecnologia">Ciência e Tecnologia <a href="#topo">^</a></h1>

<ul>
<li><p><a href="http://www.kurzweilai.net/implantable-brain-electronics-is-here">Implantable brain electronics is here</a></p>

<p><img src="CT7_ImplantableBrainElectronicsIsH.jpg" alt="CT7_ImplantableBrainElectronicsIsH" /></p>

<p><em>"In a world first,  U.S. and Chinese scientists have developed a method to inject microelectronic devices such as wires and transistors directly into the brain (or other body parts) to measure or stimulate neural activity. The new method could lead to sophisticated new ways to treat conditions ranging from neurodegenerative disorders to paralysis. Developed by researchers in Charles Lieber’s lab at Harvard University and the National Center for Nanoscience and Technology in Beijing, the invention is based on a simple but radical concept: injecting a biocompatible polymer scaffold mesh with attached microelectronic devices into the brain via syringe."</em></p></li>
<li><p><a href="http://ricoh.com/release/2015/0518_1.html">"Energy-Generating Rubber" Combines Flexibility and High-Output</a></p>

<p><img src="CT7_EnergyGeneratingRubberCombines.jpg" alt="CT7_EnergyGeneratingRubberCombines" /></p>

<p><em>"Ricoh today announced that it has created a novel flexible material "Energy-Generating Rubber" that converts pressure and vibration into electric energy with high efficiency. Currently, piezoelectric materials, which generate electricity with mechanical strain, are drawing attention as energy-harvesting* materials. Major piezoelectric materials are ceramics and polymers, but they have some deficits which prevent them from wide prevalence. Piezoelectric ceramics are used for restricted purposes because of their fragility and heavy weight although they generate relatively high electricity. On the other hand, piezoelectric polymers generate very slight electricity although they achieve flexibility by reducing the thickness. The "Energy-Generating Rubber" created by Ricoh generates as high a level of electricity as ceramics while its appearance is a soft and flexible sheet. Since it overcomes the deficits of previous piezoelectric ceramics and polymers, it is expected to be applied to multiple areas combining the advantages of flexibility and high-output."</em></p></li>
<li><p><a href="http://www.nature.com/srep/2015/150605/srep11045/full/srep11045.html">Structural color printing based on plasmonic metasurfaces of perfect light absorption</a></p>

<p><img src="CT7_StructuralColorPrintingBasedOn.jpg" alt="CT7_StructuralColorPrintingBasedOn" /></p>

<p><em>"Subwavelength structural color filtering and printing technologies employing plasmonic nanostructures have recently been recognized as an important and beneficial complement to the traditional colorant-based pigmentation. However, the color saturation, brightness and incident angle tolerance of structural color printing need to be improved to meet the application requirement. Here we demonstrate a structural color printing method based on plasmonic metasurfaces of perfect light absorption to improve color performances such as saturation and brightness. Thin-layer perfect absorbers with periodic hole arrays are designed at visible frequencies and the absorption peaks are tuned by simply adjusting the hole size and periodicity. Near perfect light absorption with high quality factors are obtained to realize high-resolution, angle-insensitive plasmonic color printing with high color saturation and brightness. Moreover, the fabricated metasurfaces can be protected with a protective coating for ambient use without degrading performances. The demonstrated structural color printing platform offers great potential for applications ranging from security marking to information storage."</em></p></li>
<li><p><a href="http://www.binghamton.edu/mpr/news-releases/news-release.html?id=2307">Binghamton engineer creates origami battery</a></p>

<p><img src="CT7_BinghamtonEngineerCreatesOriga.jpg" alt="CT7_BinghamtonEngineerCreatesOriga" /></p>

<p><em>"Origami, the Japanese art of paper folding, can be used to create beautiful birds, frogs and other small sculptures. Now a Binghamton University engineer says the technique can be applied to building batteries, too.
Seokheun "Sean" Choi developed an inexpensive, bacteria-powered battery made from paper, he writes in the July edition of the journal Nano Energy."</em></p></li>
</ul>

<hr />

<h1 id="Cursos-MOOC">Cursos MOOC <a href="#topo">^</a></h1>

<ul>
<li><a href="https://www.edx.org/course/introduction-computer-programming-part-1-iitbombayx-cs101-1x-0#!#!">Introduction to Computer Programming, Part 1</a> - Começa a 16 de Junho.</li>
<li><a href="https://www.coursera.org/course/androidpart2">Programming Mobile Applications for Android Handheld Systems: Part 2 </a> - Começa a 17 de Junho.</li>
<li><a href="https://www.coursera.org/course/interactivepython2">An Introduction to Interactive Programming in Python (Part 2)</a> - Começa a 11 de Julho.</li>
<li><a href="https://www.futurelearn.com/courses/creative-coding">Creative Coding</a> - Começa a 3 de Agosto.</li>
</ul>

<hr />

<h1 id="Modelos-3D">Modelos 3D <a href="#topo">^</a></h1>

<p>Com a disponibilidade de ferramentas que permitem dar azo a nossa imaginação na criação de peças 3D e espaços como o <a href="http://www.thingiverse.com/">thingiverse</a> para as publicar, esta rubrica apresenta alguns modelos selecionados que poderão ser úteis.</p>

<h2>Duplicating House Keys (<a href="http://www.thingiverse.com/thing:8925">http://www.thingiverse.com/thing:8925</a>)</h2>

<p><img src="MP7_DuplicatingHouseKeys.jpg" alt="Modelos3D_1_3d_printed_key_display_large_preview_featured" /></p>

<p>Full writeup on my blog at: <a href="http://eclecti.cc/hardware/physical-keygen-duplicating-house-keys-on-a-3d-printer">http://eclecti.cc/hardware/physical-keygen-duplicating-house-keys-on-a-3d-printer</a></p>

<p>It occurred to me recently that I had printed almost nothing actually useful on my RepRap 3D printer, aside from parts to improve on or build more RepRaps. I am rectifying that with this project. The goal here is to generate working house keys by inputing the key code of the lock into a parametric OpenSCAD model. Instead of having to explain to my landlord how I ended up with a wedge of plastic jammed in my front door, I ordered a box of (well) used locks and latches from eBay to experiment on. Luckily, the lot includes both Kwikset KW1 and Schlage SC1 locks, which are the two most commonly found in the US. I created an SC1 model to start with, but Iâ€™ll probably make a KW1 soon.</p>

<p>EDIT: I uploaded a KW1 model as well.</p>

<p>Designing the key model was actually pretty straightforward. I measured a key with a ruler and calipers and created an approximate model of it that is reasonably easy to print. I then got pin depth specifications and parametrically differenced them out of the model. To generate new keys, you can just edit the last line of the file and enter in the key code for your key. If the code isnâ€™t written on the key, you can measure the height of each bit and compare to the numbers in the Root Depth column on the aforementioned pin depth site. Perhaps more nefariously, you could implement something like SNEAKEY to generate key codes without physically measuring the key.</p>

<h2>LED Light Diffuser (for 3mm and 5mm LEDs) (<a href="http://www.thingiverse.com/thing:866530">http://www.thingiverse.com/thing:866530</a>)</h2>

<p><img src="MP7_LedLightDiffuserFor3MmAnd5MmLe.jpg" alt="Modelos3D_2_IMG_6402_preview_featured" /></p>

<p>I made these simple LED light diffusers for 3mm and 5mm LEDs.</p>

<p>No glue is needed, just push the diffusers onto the LEDs, and they should fit snugly enough not to fall off.</p>

<p>I suggest printing in transparent PLA/ABS, but I guess nice effects can be achieved with other colors as well, even if not transparent. For my project, I needed them to be transparent.</p>

<p>The last photo shows the project I made them for, a 4x4x4 touch screen controlled LED cube.</p>

<hr />

<h1 id="Open-Source">Open Source <a href="#topo">^</a></h1>

<h2>7-zip</h2>

<p><img src="OpenSource_7zip.png" alt="OpenSource_7zip" /></p>

<p>O 7-Zip é uma ferramenta usada para criar arquivos comprimidos e para descomprimi-los. Foi criada por Igor Pavlov em 1999 e tem vindo a ser desenvolvida desde então.
É sem dúvida uma das melhores ferramentas deste tipo. O 7zip é distribuído com uma licença LGPL e é livre para ser usado por qualquer um.
O software pode ser descarregado deste <a href="http://www.7-zip.org/">link</a>. Encontra-se actualmente na versão 15.05 beta.</p>

<p><img src="OpenSource_7zip_screenshot.png" alt="OpenSource_7zip_screenshot" /></p>

<p>As principais funcionalidades são:</p>

<ul>
<li>Formato 7z com um nível muito alto de compressão - usa os algoritmos LZMA e LZMA2</li>
<li>Suporte de múltiplos formatos:

<ul>
<li>Compressão/Descompressão: 7z, XZ, BZIP2, GZIP, TAR, ZIP e WIM</li>
<li>Só descompressão: ARJ, CAB, CHM, CPIO, CramFS, DEB, DMG, FAT, HFS, ISO, LZH, LZMA, MBR, MSI, NSIS, NTFS, RAR, RPM, SquashFS, UDF, VHD, WIM, XAR e Z.</li>
</ul></li>
<li>Para o ZIP/GZIP o 7-Zip consegue taxas de compressão 2 a 10% melhores que o PkZIP/Winzip</li>
<li>Encriptação forte AES-256 para o 7z e ZIP/GZIP</li>
<li>Capacidade de criar ficheiros Auto-descomprimíveis</li>
<li>Integração com a Shell do Windows</li>
<li>Gestor de ficheiros poderoso</li>
<li>Versão de linha de comandos</li>
<li>Localização para 87 línguas</li>
</ul>

<p>O 7-Zip corre em todas as versões de Windows. Existe uma versão de linha de comando para Linux - o <a href="http://p7zip.sourceforge.net/">p7zip</a>.</p>

<p>Links úteis:</p>

<ul>
<li><a href="http://7zsfx.info/en/">7z SFX Modified Module and Tools</a></li>
<li><a href="http://www.7-zip.org/7z.html">7z Format</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/6e6f6d1b-95c3-46df-8a26-b7efd8ee4b57/entry/how_to_use_7zip_on_linux_command_line144?lang=en">How to use 7zip on Linux command Line</a></li>
</ul>

<hr />

<h1 id="Circuitos">Circuitos <a href="#topo">^</a></h1>

<p>Aqui é apresentado um circuito simples que poderá ser construído com componentes.</p>

<h2>Controlo de LEDs de 7 Segmentos e de Matriz de 8x8</h2>

<p><img src="Circuitos_1.jpg" alt="Circuitos_1" /></p>

<p>O envio de informação do micro-controlador para o utilizar é de extrema importância para ajudar na interação entre ambos.</p>

<p>A utilização de LEDs de 7 Segmentos é uma prática comum, uma vez que são dispositivos simples de usar e que permitem o envio de informação numérica.
Neste artigo iremos ver o controlo de um conjunto de LED de 7 Segmentos controlados pelo 74HC595 e pelo CD4511.</p>

<p>Os LED de 7 Segmentos têm diversas variantes e tipicamente têm 1, 2, 3 ou 4 dígitos. Podem ser de cátodo comum ou de anodo comum.
O cátodo (-) indica a polaridade negativa e o ânodo (+) a positiva de uma fonte de energia.</p>

<p>Iremos também ver a utilização de outro integrado - o MAX7219 - que é mais potente e permite controlar até 8 LEDs de 7 Segmentos
ou uma matriz de LEDs de 8x8.</p>

<p>Uma matriz de LED de 8x8 pode ser Cátodo Linha/Ânodo Coluna ou Ânodo Linha/Cátodo Coluna. Em função da tipologia da mesma logo as conexões têm que ser invertidas.</p>

<p>Para o 74HC595 é usada uma interface Série para Paralela que já foi abordada no artigo da <a href="../6/index.html#Circuitos">Newsletter Nº6</a>.</p>

<p>Para o CD4511 é convertido o número passado em binário em quatro pinos para o LED de 7 Segmentos.</p>

<p>No caso do MAX7219 é usado um interface <a href="http://www.arduino.cc/en/Reference/SPI">SPI</a> para o envio da informação para o integrado.</p>

<h2>Esquemático</h2>

<p>Com o 74HC595:</p>

<p><img src="Circuitos_3_Schematics.png" alt="Circuitos_3_Schematics" /></p>

<p>Com o CD4511:</p>

<p><img src="Circuitos_3_Schematics2.png" alt="Circuitos_3_Schematics2" /></p>

<p>Com o MAX7219:</p>

<p><img src="Circuitos_3_Schematics3.png" alt="Circuitos_3_Schematics3" /></p>

<p>Para a matriz de 8x8 LEDs:</p>

<p><img src="Circuitos_3_Schematics4.png" alt="Circuitos_3_Schematics4" /></p>

<p>A numeração usada nos LEDs de Segmentos e nas matrizes de cubos é idêntica aos Chips DIP.</p>

<p><img src="Circuitos_3_LEDs7Seg1.png" alt="Circuitos_3_LEDs7Seg1" />
<img src="Circuitos_3_LEDs7Segments.png" alt="Circuitos_3_LEDs7Segments" />
<img src="Circuitos_3_LEDs8x8.png" alt="Circuitos_3_LEDs8x8" /></p>

<p>As ligações entre o LED 4x 7-Segmentos foi a seguinte:</p>

<table>
<thead>
<tr>
  <th>Display 4 x 7-Segmentos</th>
  <th>MAX 7219</th>
  <th>7-Segment Code</th>
  <th>Segmento</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1</td>
  <td>21</td>
  <td>E</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>2</td>
  <td>23</td>
  <td>D</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>3</td>
  <td>22</td>
  <td>DP</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>4</td>
  <td>20</td>
  <td>C</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>5</td>
  <td>17</td>
  <td>G</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>6</td>
  <td>7</td>
  <td>D4</td>
  <td>Esquerda</td>
</tr>
<tr>
  <td>7</td>
  <td>16</td>
  <td>B</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>8</td>
  <td>6</td>
  <td>D3</td>
  <td>Esquerda</td>
</tr>
<tr>
  <td>9</td>
  <td>11</td>
  <td>D2</td>
  <td>Esquerda</td>
</tr>
<tr>
  <td>10</td>
  <td>15</td>
  <td>F</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>11</td>
  <td>14</td>
  <td>A</td>
  <td>Ambos</td>
</tr>
<tr>
  <td>12</td>
  <td>2</td>
  <td>D1</td>
  <td>Esquerda</td>
</tr>
<tr>
  <td>6</td>
  <td>8</td>
  <td>D4</td>
  <td>Direita</td>
</tr>
<tr>
  <td>8</td>
  <td>5</td>
  <td>D3</td>
  <td>Direita</td>
</tr>
<tr>
  <td>9</td>
  <td>10</td>
  <td>D2</td>
  <td>Direita</td>
</tr>
<tr>
  <td>12</td>
  <td>3</td>
  <td>D1</td>
  <td>Direita</td>
</tr>
</tbody>
</table>

<p>As Ligações entre o MAX7219 e a Matriz de 8x8:</p>

<table>
<thead>
<tr>
  <th>Matriz 8x8</th>
  <th>MAX7219</th>
</tr>
</thead>
<tbody>
<tr>
  <td>9</td>
  <td>22</td>
</tr>
<tr>
  <td>14</td>
  <td>14</td>
</tr>
<tr>
  <td>8</td>
  <td>16</td>
</tr>
<tr>
  <td>12</td>
  <td>20</td>
</tr>
<tr>
  <td>1</td>
  <td>23</td>
</tr>
<tr>
  <td>7</td>
  <td>21</td>
</tr>
<tr>
  <td>2</td>
  <td>15</td>
</tr>
<tr>
  <td>5</td>
  <td>17</td>
</tr>
<tr>
  <td>13</td>
  <td>2</td>
</tr>
<tr>
  <td>3</td>
  <td>11</td>
</tr>
<tr>
  <td>4</td>
  <td>6</td>
</tr>
<tr>
  <td>10</td>
  <td>7</td>
</tr>
<tr>
  <td>6</td>
  <td>3</td>
</tr>
<tr>
  <td>11</td>
  <td>10</td>
</tr>
<tr>
  <td>15</td>
  <td>5</td>
</tr>
<tr>
  <td>16</td>
  <td>8</td>
</tr>
</tbody>
</table>

<p>Nota:
O circuito para o CSEduino pode ser consultado no <a href="../5/index.html#Artigo-do-Maker">Artigo do Maker da Newsletter Nº5</a>. Pode igualmente ser usado um Arduino.</p>

<h2>Componentes (BOM):</h2>

<p>Para o Circuito com o 74HC595:</p>

<ul>
<li><a href="https://altlab.org/d/m/jpralves/newsletters/5/#Artigo-do-Maker#Artigo-do-Maker">CSEduino</a></li>
<li>74HC595</li>
<li>8 Resistências de 470 Ohm</li>
<li>1 <a href="http://www.tme.eu/en/Document/015ba760a7ea42af07efd67dec330267/LSD056BUE-101C.pdf">LED 7 Segmentos anodo comum</a></li>
<li>1 <a href="http://www.tme.eu/en/Document/4af3fcd10918734d6523badeb80ba806/LSD056AUE-101B.pdf">LED 7 Segmentos Cátodo comum</a></li>
</ul>

<p>Para o Circuito com o CD4511:</p>

<ul>
<li><a href="https://altlab.org/d/m/jpralves/newsletters/5/#Artigo-do-Maker#Artigo-do-Maker">CSEduino</a></li>
<li><a href="http://www.ti.com/lit/ds/symlink/cd4511b.pdf">CD4511</a></li>
<li>8 Resistências de 470 Ohm</li>
<li>1 LED 7 Segmentos Ânodo comum</li>
<li>1 LED 7 Segmentos Cátodo comum</li>
</ul>

<p>Para o Circuito com o MAX7219:</p>

<ul>
<li><a href="https://altlab.org/d/m/jpralves/newsletters/5/#Artigo-do-Maker#Artigo-do-Maker">CSEduino</a></li>
<li><a href="http://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf">MAX7219</a></li>
<li>1 Condensador Electrolítico de 100uF</li>
<li>1 Condensador Cerâmico de 100nF</li>
<li>1 Resistência de 10K Ohm</li>
<li>LED 8x8 Cátodo Linha/Ânodo Coluna (788BS)</li>
</ul>

<h2>Pin-out dos IC</h2>

<p><img src="Circuitos_4_Pinout.png" alt="Circuitos_4_Pinout" /></p>

<h2>Código</h2>

<p><img src="Circuitos_5_74HC595.jpg" alt="Circuitos_5_74HC595" /></p>

<p>O <em>Sketch</em> usado para o 74HC595 foi o seguinte:</p>

<pre><code>//  Filename: control7Seg-74hc595.ino

#define LATCH 12
#define CLOCK 11
#define DATA 10
#define INTENSITY 9

const int patternDelay = 500;

// adder = 0 - Common Cathode
// adder = 255 - Common Anode

//const byte adder = 0;
const byte adder = 255;

const byte test_pattern[] = { 0,1,2,4,8,16,32,64,128 };

void testLeds() {
  for (int numberToDisplay = 0; numberToDisplay &lt; sizeof(test_pattern); numberToDisplay++) {
    digitalWrite(LATCH, LOW);
    shiftOut(DATA, CLOCK, MSBFIRST, adder ? adder-test_pattern[numberToDisplay] : test_pattern[numberToDisplay] );
    digitalWrite(LATCH, HIGH);
    delay(100);
  }
}

void setup() {
  //set pins to output so you can control the shift register
  pinMode(LATCH, OUTPUT);
  pinMode(CLOCK, OUTPUT);
  pinMode(DATA, OUTPUT);
  pinMode(INTENSITY, OUTPUT);
  digitalWrite(INTENSITY, LOW);  // Funciona ao contrário
  testLeds();
}

#define _TL 64
#define _TR 16
#define _BL 1
#define _BR 4
#define _BT 2
#define _TP 32
#define _MD 128
#define _DE 8

const byte pattern[] PROGMEM = {
0,
_TP + _TR + _BR + _BT + _BL + _TL,
      _TR + _BR,
_TP + _TR +       _BT + _BL +       _MD,
_TP + _TR + _BR + _BT +             _MD,
      _TR + _BR +             _TL + _MD,
_TP +       _BR + _BT +       _TL + _MD,
_TP +       _BR + _BT + _BL + _TL + _MD,
_TP + _TR + _BR,
_TP + _TR + _BR + _BT + _BL + _TL + _MD,
_TP + _TR + _BR + _BT +       _TL + _MD
};

void loop()
{
    for (int numberToDisplay = 0; numberToDisplay &lt; sizeof(pattern); numberToDisplay++) {
      digitalWrite(LATCH, LOW);
      shiftOut(DATA, CLOCK, MSBFIRST, adder ? adder-pattern[numberToDisplay] : pattern[numberToDisplay] );
      digitalWrite(LATCH, HIGH);
      delay(patternDelay);
    }
}
</code></pre>

<p>Este <em>sketch</em> funciona tanto para Segmento de 7 LEDs com Cátodo comum como com Ânodo comum. Para isso deverá ser alterada a variavel <em>adder</em> da seguinte forma:</p>

<ul>
<li>Cátodo Comum: const byte adder = 0</li>
<li>Ânodo comum: const byte adder = 255</li>
</ul>

<p><img src="Circuitos_5_CD4511.jpg" alt="Circuitos_5_CD4511" /></p>

<p>O <em>Sketch</em> usado para o CD4511 foi o seguinte:</p>

<pre><code>//  Filename: control7Seg-cd4511.ino

// Pinos: A0, A1, A2, A3 do CD4511
const byte pins[] = { 2,3,4,5 };

void setup() {
  for (int i=0; i&lt;sizeof(pins);i++) {
    pinMode(pins[i],OUTPUT);
  }
}

void loop() {
  for (int n=0; n&lt;10; n++) {
    for(int i=0; i&lt;sizeof(pins);i++) {
      digitalWrite(pins[i],n &amp; (1 &lt;&lt; i) ? HIGH : LOW);
    }
    delay(250);
  }
}
</code></pre>

<p><img src="Circuitos_5_MAX7219_7SEG.jpg" alt="Circuitos_5_MAX7219_7SEG" /></p>

<p>O <em>Sketch</em> usado para o MAX7219 foi o seguinte:</p>

<pre><code>//  Filename: control7Seg-max7219.ino

#include "LedControl.h"

LedControl lc = LedControl(11,13,10,1);

unsigned long delaytime = 250;

void setup() {
  lc.shutdown(0,false);
  lc.setIntensity(0,8);
  lc.clearDisplay(0);
}

void writeChar(byte px, byte py, byte ch) {
   if (ch &gt;= 32)  {
     lc.setChar(px,py,ch,false);
   } else {
     lc.setRow(px,py,ch);
   }
}

void writeArduinoOn7Segment() {
  byte cseduino[] = {'c','5','e','d',0x1c,B00010000,0x15,0x1D,'-','H','e','l','p','-','-','-'};
  for(int i = 0; i&lt;sizeof(cseduino) - 7; i++) {
    writeChar(0, 7, cseduino[i+7]);
    writeChar(0, 6, cseduino[i+6]);
    writeChar(0, 5, cseduino[i+5]);
    writeChar(0, 4, cseduino[i+4]);
    writeChar(0, 3, cseduino[i+3]);
    writeChar(0, 2, cseduino[i+2]);
    writeChar(0, 1, cseduino[i+1]);
    writeChar(0, 0, cseduino[i]);
    delay(delaytime*1000);
  }
}

void scrollDigits() {
  for(int i=0;i&lt;16-7;i++) {
    lc.setDigit(0, 0, i, false);
    lc.setDigit(0, 1, i+1, false);
    lc.setDigit(0, 2, i+2, false);
    lc.setDigit(0, 3, i+3, false);
    lc.setDigit(0, 4, i+4, false);
    lc.setDigit(0, 5, i+5, false);
    lc.setDigit(0, 6, i+6, false);
    lc.setDigit(0, 7, i+7, false);
    delay(delaytime);
  }
  lc.clearDisplay(0);
  delay(delaytime);
}

void loop() {
  writeArduinoOn7Segment();
  scrollDigits();
}
</code></pre>

<p>Para este <em>sketch</em> funcionar é necessário importar a biblioteca <em>Ledcontrol</em> neste <a href="https://github.com/wayoda/LedControl/releases">link</a>.</p>

<p><img src="Circuitos_5_MAX7219_8x8.jpg" alt="Circuitos_5_MAX7219_8x8" /></p>

<p>O <em>sketch</em> para controlar os LEDs 8x8:</p>

<pre><code>//  Filename: control8x8-max7219.ino

//We always have to include the library
#include "LedControl.h"

/*
 Now we need a LedControl to work with.
 ***** These pin numbers will probably not work with your hardware *****
 pin 12 is connected to the DataIn
 pin 11 is connected to the CLK
 pin 10 is connected to LOAD
 We have only a single MAX72XX.
 */
LedControl lc=LedControl(11, 13, 10, 1);

/* we always wait a bit between updates of the display */
unsigned long delaytime=100;

void setup() {
  /*
   The MAX72XX is in power-saving mode on startup,
   we have to do a wakeup call
   */
  lc.shutdown(0,false);
  /* Set the brightness to a medium values */
  lc.setIntensity(0,8);
  /* and clear the display */
  lc.clearDisplay(0);
}

/*
 This method will display the characters for the
 word "Arduino" one after the other on the matrix.
 (you need at least 5x7 leds to see the whole chars)
 */
void writeArduinoOnMatrix() {
  /* here is the data for the characters */
  byte a[5]={B01111110,B10001000,B10001000,B10001000,B01111110};
  byte r[5]={B00111110,B00010000,B00100000,B00100000,B00010000};
  byte d[5]={B00011100,B00100010,B00100010,B00010010,B11111110};
  byte u[5]={B00111100,B00000010,B00000010,B00000100,B00111110};
  byte i[5]={B00000000,B00100010,B10111110,B00000010,B00000000};
  byte n[5]={B00111110,B00010000,B00100000,B00100000,B00011110};
  byte o[5]={B00011100,B00100010,B00100010,B00100010,B00011100};

  /* now display them one by one with a small delay */
  lc.setRow(0,0,a[0]);
  lc.setRow(0,1,a[1]);
  lc.setRow(0,2,a[2]);
  lc.setRow(0,3,a[3]);
  lc.setRow(0,4,a[4]);
  delay(delaytime);
  lc.setRow(0,0,r[0]);
  lc.setRow(0,1,r[1]);
  lc.setRow(0,2,r[2]);
  lc.setRow(0,3,r[3]);
  lc.setRow(0,4,r[4]);
  delay(delaytime);
  lc.setRow(0,0,d[0]);
  lc.setRow(0,1,d[1]);
  lc.setRow(0,2,d[2]);
  lc.setRow(0,3,d[3]);
  lc.setRow(0,4,d[4]);
  delay(delaytime);
  lc.setRow(0,0,u[0]);
  lc.setRow(0,1,u[1]);
  lc.setRow(0,2,u[2]);
  lc.setRow(0,3,u[3]);
  lc.setRow(0,4,u[4]);
  delay(delaytime);
  lc.setRow(0,0,i[0]);
  lc.setRow(0,1,i[1]);
  lc.setRow(0,2,i[2]);
  lc.setRow(0,3,i[3]);
  lc.setRow(0,4,i[4]);
  delay(delaytime);
  lc.setRow(0,0,n[0]);
  lc.setRow(0,1,n[1]);
  lc.setRow(0,2,n[2]);
  lc.setRow(0,3,n[3]);
  lc.setRow(0,4,n[4]);
  delay(delaytime);
  lc.setRow(0,0,o[0]);
  lc.setRow(0,1,o[1]);
  lc.setRow(0,2,o[2]);
  lc.setRow(0,3,o[3]);
  lc.setRow(0,4,o[4]);
  delay(delaytime);
  lc.setRow(0,0,0);
  lc.setRow(0,1,0);
  lc.setRow(0,2,0);
  lc.setRow(0,3,0);
  lc.setRow(0,4,0);
  delay(delaytime);
}

/*
  This function lights up a some Leds in a row.
 The pattern will be repeated on every row.
 The pattern will blink along with the row-number.
 row number 4 (index==3) will blink 4 times etc.
 */
void rows() {
  for(int row=0;row&lt;8;row++) {
    delay(delaytime);
    lc.setRow(0,row,B10100000);
    delay(delaytime);
    lc.setRow(0,row,(byte)0);
    for(int i=0;i&lt;row;i++) {
      delay(delaytime);
      lc.setRow(0,row,B10100000);
      delay(delaytime);
      lc.setRow(0,row,(byte)0);
    }
  }
}

/*
  This function lights up a some Leds in a column.
 The pattern will be repeated on every column.
 The pattern will blink along with the column-number.
 column number 4 (index==3) will blink 4 times etc.
 */
void columns() {
  for(int col=0;col&lt;8;col++) {
    delay(delaytime);
    lc.setColumn(0,col,B10100000);
    delay(delaytime);
    lc.setColumn(0,col,(byte)0);
    for(int i=0;i&lt;col;i++) {
      delay(delaytime);
      lc.setColumn(0,col,B10100000);
      delay(delaytime);
      lc.setColumn(0,col,(byte)0);
    }
  }
}

/*
 This function will light up every Led on the matrix.
 The led will blink along with the row-number.
 row number 4 (index==3) will blink 4 times etc.
 */
void single() {
  for(int row=0;row&lt;8;row++) {
    for(int col=0;col&lt;8;col++) {
      delay(delaytime);
      lc.setLed(0,row,col,true);
      delay(delaytime);
      for(int i=0;i&lt;col;i++) {
        lc.setLed(0,row,col,false);
        delay(delaytime);
        lc.setLed(0,row,col,true);
        delay(delaytime);
      }
    }
  }
}

void loop() {
  writeArduinoOnMatrix();
  rows();
  columns();
  single();
}
</code></pre>

<p>Todos os <em>sketchs</em> encontram-se num ZIP neste <a href="newsletter7-sketchs.zip">link</a></p>

<p>Links úteis:</p>

<ul>
<li><a href="http://www.allaboutcircuits.com/textbook/experiments/chpt-7/7-segment-display/">7-segment Display</a></li>
<li><a href="http://playground.arduino.cc/Main/MAX72XXHardware">The MAX7219 and MAX7221 Led drivers</a></li>
<li><a href="http://www.gammon.com.au/forum/?id=11516">Interfacing LED displays with the MAX7219 driver</a></li>
<li><a href="http://familiemeier.ch/robertsblog/2013/11/02/driving-8x8-led-matrix-ld-1088bs/">Driving 8×8 LED Matrix (LD-1088BS)</a></li>
</ul>

<hr />

<h1 id="Assunto-Geek">Assunto Geek <a href="#topo">^</a></h1>

<p>Um assunto que interessa aos Geeks e não só</p>

<h2>Optimizações de AVR</h2>

<p>No mundo dos micro-controladores e ao contrário do mundo dos computadores, os recursos são escassos e todas as optimizações que possam ser feitas são muito úteis.
Neste artigo iremos abordar algumas das várias optimizações que podem ser feitas para que o código final carregado no micro-controlador seja mais pequeno e potencialmente mais rápido.
Irei focar-me na optimização que pode ser obtida nos <em>chips</em> da família Atmega/Attiny. No entanto algumas destas abordagens podem ser seguidas para qualquer tipo de micro-controlador.</p>

<p>Partirei de um exemplo simples e iremos observar que com algumas alterações a redução de código produzido pelo compilador é muito significativa.</p>

<p>Existem 18 recomendações que globalmente diminuem o tamanho do código:</p>

<ol>
<li>Compilar com optimização por tamanho (-Os). O Arduino IDE já tem esta <em>flag</em> ativa por omissão.</li>
<li>Usar variáveis locais sempre que possível.</li>
<li>Usar o tipo de dados mais pequeno aplicável. Usar variáveis sem sinal se possível.</li>
<li>Se uma variável não local apenas é referenciada dentro de função deverá ser declarada estática.</li>
<li>Juntar variáveis não locais em estruturas sempre que seja natural. Isto aumenta a possibilidade de endereçamento indirecto sem recarregamento do apontador.</li>
<li>Usar apontadores com deslocamento (<em>offset</em>) ou declarar estruturas para aceder ao <em>I/O memory mapped</em>.</li>
<li>Usar o Use for(;;) { } para ciclos externos.</li>
<li>Usar o <em>do { } while(expressão)</em> se aplicável.</li>
<li>Usar contadores descendentes e pre-decrementos se aplicável.</li>
<li>Aceder à memory de I/O directamente (i.e., não usar apontadores).</li>
<li>Declarar a <em>main</em> como <em>C_task</em> se não for chamada de nenhum lado do programa.</li>
<li>Usar macros em vez de funções para tarefas que criem menos de 2-3 linhas de código assembler.</li>
<li>Reduzir o tamanho do <em>Interrupt Vector segment</em> (INTVEC) para o que é atualmente usado pela aplicação. Alternativamente, concatenar todos os <em>CODE segments</em> numa declaração e será feito automaticamente.</li>
<li>A reutilização de código é intra-modular. Conjugue varias funções num módulo (i.e., num ficheiro) para aumentar o factor de reutilização de código.</li>
<li>Em alguns casos, as optimizações por velocidade resultam em código de tamanho menor que a optimização por tamanho. Compilar módulo a módulo para verificar qual apresenta melhor resultado.</li>
<li>Optimizar o <em>C_startup</em> para não inicializar segmentos não usados (i.e., IDATA0 ou IDATA1 se todas as variáveis são pequenas).</li>
<li>Se possível, evite chamar funções de dentro da rotina de interrupção.</li>
<li>Usar o modelo de memória menor possível.</li>
</ol>

<p>Iremos fazer uso de algumas destas recomendações. Para se testar o resultado das optimizações iremos partir de um código base.</p>

<p>Todos os <em>sketchs</em> encontram-se num ZIP neste <a href="newsletter7-sketchs.zip">link</a></p>

<p>O seguinte código é uma versão modificada do <em>Blink</em> que vai piscar dois leds com um intervalo variável entre 0 e 1000 mseg com saltos de 100 em 100 mseg.</p>

<pre><code>int led1 = 13;
int led2 = 12;
int delayTime = 1000;

void setup() {
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);
}

void loop() {
  for (delayTime = 0; delayTime &lt; 1000 ; delayTime += 100) {
    digitalWrite(led1, HIGH);
    delay(delayTime);
    digitalWrite(led1, LOW);
    delay(delayTime);
    digitalWrite(led2, HIGH);
    delay(delayTime);
    digitalWrite(led2, LOW);
    delay(delayTime);
  }
}
// Sketch uses 1,198 bytes (3%) of program storage space. Maximum is 32,256 bytes.
// Global variables use 15 bytes (0%) of dynamic memory, leaving 2,033 bytes for local variables. Maximum is 2,048 bytes.
</code></pre>

<p>Como podemos observar o código original ocupa 1196 bytes de <em>flash</em>.</p>

<p>Usando a optimização do espaço ocupado pelas variáveis iremos alterar o seu tipo:</p>

<table>
<thead>
<tr>
  <th>Tipo</th>
  <th align="center">Intervalo de valores</th>
  <th align="right">Nº de Bytes</th>
</tr>
</thead>
<tbody>
<tr>
  <td>char</td>
  <td align="center">-128 a 127</td>
  <td align="right">1</td>
</tr>
<tr>
  <td>byte</td>
  <td align="center">0 a 255</td>
  <td align="right">1</td>
</tr>
<tr>
  <td>int</td>
  <td align="center">-32,768 a 32,767</td>
  <td align="right">2*</td>
</tr>
<tr>
  <td>unsigned int</td>
  <td align="center">0 a 65,535</td>
  <td align="right">2*</td>
</tr>
<tr>
  <td>word</td>
  <td align="center">0 a 65,535</td>
  <td align="right">2</td>
</tr>
<tr>
  <td>long</td>
  <td align="center">-2,147,483,648 a 2,147,483,647</td>
  <td align="right">4</td>
</tr>
<tr>
  <td>unsigned long</td>
  <td align="center">0 a 4,294,967,295</td>
  <td align="right">4</td>
</tr>
<tr>
  <td>float</td>
  <td align="center">-3.4028235E+38 a 3.4028235E+38</td>
  <td align="right">4</td>
</tr>
<tr>
  <td>double</td>
  <td align="center">-3.4028235E+38 a 3.4028235E+38</td>
  <td align="right">4*</td>
</tr>
</tbody>
</table>

<p>Os valores com (*) são para o chip Atmega328P. Noutros poderá ser diferente.</p>

<h3>Passo 1</h3>

<p>No exemplo podemos verificar que a declaração dos leds pode ser convertida em <em>byte</em>.</p>

<p>Adicionalmente pode igualmente ser convertida em <em>const</em> uma vez que não são alteradas (esta informação é essencial para o compilador optimizar a utilização destas variáveis).</p>

<p>Este passo é totalmente seguro e pode sempre ser feito.</p>

<pre><code>const byte led1 = 13;
const byte led2 = 12;
int delayTime = 1000;

void setup() {
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);
}

void loop() {
  for (delayTime = 0; delayTime &lt; 1000; delayTime += 100) {
    digitalWrite(led1, HIGH);
    delay(delayTime);
    digitalWrite(led1, LOW);
    delay(delayTime);
    digitalWrite(led2, HIGH);
    delay(delayTime);
    digitalWrite(led2, LOW);
    delay(delayTime);
  }
}
// Sketch uses 1,182 bytes (3%) of program storage space. Maximum is 32,256 bytes.
// Global variables use 11 bytes (0%) of dynamic memory, leaving 2,037 bytes for local variables. Maximum is 2,048 bytes.
</code></pre>

<p>O ganho foi de 16 bytes.</p>

<h3>Passo 2</h3>

<p>Vamos agora passar a variável global <em>delayTime</em> para local da função <em>loop</em>.</p>

<p>Este passo é totalmente seguro e pode sempre ser feito.</p>

<pre><code>const byte led1 = 13;
const byte led2 = 12;

void setup() {
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);
}

void loop() {

  int delayTime;

  for (delayTime = 0; delayTime &lt;= 1000; delayTime += 100) {
    digitalWrite(led1, HIGH);
    delay(delayTime);
    digitalWrite(led1, LOW);
    delay(delayTime);
    digitalWrite(led2, HIGH);
    delay(delayTime);
    digitalWrite(led2, LOW);
    delay(delayTime);
  }
}
// Sketch uses 1,110 bytes (3%) of program storage space. Maximum is 32,256 bytes.
// Global variables use 11 bytes (0%) of dynamic memory, leaving 2,037 bytes for local variables. Maximum is 2,048 bytes.
</code></pre>

<p>Desta vez o ganho foi de 72 bytes.</p>

<h3>Passo 3</h3>

<p>Neste passo iremos encapsular funções que fazem múltiplas operações.
Neste caso criou-se uma função para executar o trabalho de um dos leds.</p>

<p>Este passo é totalmente seguro e pode sempre ser feito.</p>

<pre><code>const byte led1 = 13;
const byte led2 = 12;

void setup() {
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);
}

void go(const byte led, const int delayTime) {
    digitalWrite(led, HIGH);
    delay(delayTime);
    digitalWrite(led, LOW);
    delay(delayTime);
}

void loop() {
  int delayTime;
  for (delayTime = 0; delayTime &lt;= 1000; delayTime += 100) {
    go(led1, delayTime);
    go(led2, delayTime);
  }
}
// Sketch uses 1,102 bytes (3%) of program storage space. Maximum is 32,256 bytes.
// Global variables use 9 bytes (0%) of dynamic memory, leaving 2,039 bytes for local variables. Maximum is 2,048 bytes.
</code></pre>

<p>Apenas ganhámos 8 bytes.</p>

<h2>Passo 4</h2>

<p>Temos que tomar medidas mais radicais. Isto passa por substituir as funções <em>pinMode</em> e <em>digitalWrite</em>.</p>

<p>Esta alteração quebra algumas funcionalidades nomeadamente a relacionada com o PWM.</p>

<p>Também não é feita verificação de valores incorrectos passados às macros.
Uma vez que vamos mexer directamente com os registos o código tem um conjunto de macros que permitem o uso do código com os seguintes microcontroladores:</p>

<ul>
<li>Atmega328P</li>
<li>Atmega168</li>
<li>attiny45/85</li>
<li>attiny44/84</li>
</ul>

<p>Este código é tendencialmente mais rápido porque faz o estritamente necessário.</p>

<p>Incluir o código no topo dos <em>sketchs</em>:</p>

<pre><code>// AVR-optimize
//
#if defined (__AVR_ATtiny45__) || defined (__AVR_ATtiny85__) || defined (__AVR_ATtiny44__) || defined (__AVR_ATtiny84__)
#define portOfPin(P)\
  ((&amp;PORTB))
#define ddrOfPin(P)\
  ((&amp;DDRB))
#define pinOfPin(P)\
  ((&amp;PINB))
#define pinIndex(P)((uint8_t)(P&gt;13?P-14:P&amp;7))
#else
#if (__AVR_ATtiny44__) || defined (__AVR_ATtiny84__)
#define portOfPin(P)\
  (((P)&gt;=0&amp;&amp;(P)&lt;8)?&amp;PORTA:&amp;PORTB)
#define ddrOfPin(P)\
  (((P)&gt;=0&amp;&amp;(P)&lt;8)?&amp;DDRA:&amp;DDRB)
#define pinOfPin(P)\
  (((P)&gt;=0&amp;&amp;(P)&lt;8)?&amp;PINA:&amp;PINB)
#define pinIndex(P)((uint8_t)(P&gt;7?P-7:P&amp;7))
#else
#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)

#define portOfPin(P)\
  (((P)&gt;=0&amp;&amp;(P)&lt;8)?&amp;PORTD:(((P)&gt;7&amp;&amp;(P)&lt;14)?&amp;PORTB:&amp;PORTC))
#define ddrOfPin(P)\
  (((P)&gt;=0&amp;&amp;(P)&lt;8)?&amp;DDRD:(((P)&gt;7&amp;&amp;(P)&lt;14)?&amp;DDRB:&amp;DDRC))
#define pinOfPin(P)\
  (((P)&gt;=0&amp;&amp;(P)&lt;8)?&amp;PIND:(((P)&gt;7&amp;&amp;(P)&lt;14)?&amp;PINB:&amp;PINC))
#define pinIndex(P)((uint8_t)(P&gt;13?P-14:P&amp;7))
#endif
#endif
#endif

#define pinIndex(P)((uint8_t)(P&gt;13?P-14:P&amp;7))
#define pinMask(P)((uint8_t)(1&lt;&lt;pinIndex(P)))

#define pinAsInput(P) *(ddrOfPin(P))&amp;=~pinMask(P)
#define pinAsInputPullUp(P) *(ddrOfPin(P))&amp;=~pinMask(P);digitalHigh(P)
#define pinAsOutput(P) *(ddrOfPin(P))|=pinMask(P)
#define digitalLow(P) *(portOfPin(P))&amp;=~pinMask(P)
#define digitalHigh(P) *(portOfPin(P))|=pinMask(P)
#define isHigh(P)((*(pinOfPin(P))&amp; pinMask(P))&gt;0)
#define isLow(P)((*(pinOfPin(P))&amp; pinMask(P))==0)
#define digitalState(P)((uint8_t)isHigh(P))
</code></pre>

<p>Novo código:</p>

<pre><code>// incluir o AVR-optimize

const byte led1 = 3;
const byte led2 = 2;

void setup() {
  pinAsOutput(led1);
  pinAsOutput(led2);
}

void go(const byte led, const int delayTime) {
    digitalHigh(led);
    delay(delayTime);
    digitalLow(led);
    delay(delayTime);
}

void loop() {
  int delayTime;
  for (delayTime = 0; delayTime &lt;= 1000; delayTime += 100) {
    go(led1, delayTime);
    go(led2, delayTime);
  }
}
// Sketch uses 812 bytes (2%) of program storage space. Maximum is 32,256 bytes.
// Global variables use 9 bytes (0%) of dynamic memory, leaving 2,039 bytes for local variables. Maximum is 2,048 bytes.
</code></pre>

<p>Finalmente quebrámos a barreira do 1k.</p>

<p>Um <em>sketch</em> sem qualquer código ocupa 450 bytes. O nosso ocupa 812 bytes.</p>

<p>O que significa que o código que estamos a usar está a ocupar 362 bytes.</p>

<h2>Passo 5</h2>

<p>Ainda não substituímos uma das funções - <em>delay</em>. Neste passo fazemos essa substituição.</p>

<pre><code>// incluir o AVR-optimize

const byte led1 = 13;
const byte led2 = 12;

void setup() {
  pinAsOutput(led1);
  pinAsOutput(led2);
}

void tinyDelay(int time) {
  register unsigned long initial = millis();
  while ( millis() - initial &lt; time ) {
    yield();
  }
}

void go(const byte led, const int delayTime) {
    digitalHigh(led);
    tinyDelay(delayTime);
    digitalLow(led);
    tinyDelay(delayTime);
}

void loop() {
  int delayTime;
  for (delayTime = 0;delayTime &lt;= 1000;delayTime += 100) {
    go(led1, delayTime);
    go(led2, delayTime);
  }
}
// Sketch uses 744 bytes (2%) of program storage space. Maximum is 32,256 bytes.
// Global variables use 9 bytes (0%) of dynamic memory, leaving 2,039 bytes for local variables. Maximum is 2,048 bytes.
</code></pre>

<p>Nesta última iteração conseguimos passar para 744 bytes.</p>

<h3>Passo Final</h3>

<p>Iremos neste passo fazer ainda mais algumas optimizações:</p>

<ul>
<li>Criar o nosso próprio <em>main</em></li>
<li>voltar a descrever as operações que a função <em>go</em> fazia eliminando a função completamente</li>
<li>eliminar o <em>setup</em> e o <em>loop</em> colocando o código diretamente no <em>main</em></li>
</ul>

<pre><code>// incluir o AVR-optimize

const byte led1 = 13;
const byte led2 = 12;

void tinyDelay(int time) {
  register unsigned long initial = millis();
  while ( millis() - initial &lt; time ) {
    yield();
  }
}

int main(void) {
  init(); // don't forget this!
  // SETUP:
  pinAsOutput(led1);
  pinAsOutput(led2);
  for(;;) {
    // LOOP:
    int delayTime;
    for (delayTime = 0; delayTime &lt;= 1000; delayTime += 100) {
      digitalHigh(led1);
      tinyDelay(delayTime);
      digitalLow(led1);
      tinyDelay(delayTime);
      digitalHigh(led2);
      tinyDelay(delayTime);
      digitalLow(led2);
      tinyDelay(delayTime);
    }
  }
}
// Sketch uses 578 bytes (1%) of program storage space. Maximum is 32,256 bytes.
// Global variables use 9 bytes (0%) of dynamic memory, leaving 2,039 bytes for local variables. Maximum is 2,048 bytes.
</code></pre>

<h3>Conclusão</h3>

<p>Começamos com 1,198 bytes e conseguimos optimizar o código para 578 bytes - menos de metade do código original.</p>

<p>Este exercício deverá ser feito sempre que necessário ponderando todos os potenciais problemas que algumas das optimizações podem provocar.</p>

<p>Poderíamos ainda ter ido para o código <em>plain</em> sem bibliotecas do Arduino mas isso fica para outro artigo.</p>

<p>Links úteis:</p>

<ul>
<li><a href="http://forum.arduino.cc/index.php?topic=112878.0">How to reduce program size</a></li>
<li><a href="http://www.atmel.com/images/doc1497.pdf">AVR035: Efficient C Coding for AVR</a></li>
<li><a href="http://blog.spitzenpfeil.org/wordpress/2011/12/07/arduino-1-0-a-few-things-you-can-do-to-save-flash-space/">Arduino 1.0 — a few things you can do to save FLASH space</a></li>
<li><a href="https://ucexperiment.wordpress.com/2012/02/21/arduino-assembly-language-listing-of-compiled-sketch-windows/">Arduino Assembly Language Listing of Compiled Sketch (Windows)</a></li>
<li><a href="http://masteringarduino.blogspot.pt/2013/10/fastest-and-smallest-digitalread-and.html">Fastest digitalRead / digitalWrite Alternative</a></li>
</ul>

<h1 id="Artigo-do-Maker">Artigo do Maker <a href="#topo">^</a></h1>

<p>Projeto interessante publicado por um maker.</p>

<h2>Dot Matrix Business Card</h2>

<p>O projecto desta semana é um "Business Card" hi-tech. O maker deste projecto é o tom ward e o projecto encontra-se descrito aqui neste <a href="http://www.instructables.com/id/Dot-Matrix-Business-Card/?ALLSTEPS">link</a>.</p>

<p><img src="PM7_DotMatrixBusinessCard.jpg" alt="ArtigoMaker_1_Dot_Matrix_Business_Card" /></p>

<p>O desenho é muito simples para o que faz - uma matriz de 5x15 LEDs ligados a um micro-controlador PIC. Algumas resistências e condensadores.
Por manter o micro-controlador em modo <em>Sleep</em> a não ser que os botões sejam premidos, a bateria pode durar bastante tempo.</p>

<p>O esquemático do projeto pode ser descarregado neste <a href="http://www.instructables.com/files/orig/F5E/OJHY/FKD1LQT7/F5EOJHYFKD1LQT7.pdf">link</a></p>

<p>O que é necessário para o projecto:</p>

<h3>Materiais</h3>

<p><img src="ArtigoMaker_2_F4IWZ8VFKD1LQTD.jpg" alt="ArtigoMaker_2_F4IWZ8VFKD1LQTD" /></p>

<ul>
<li>bateria CR2032</li>
<li>receptáculo para  a Bateria CR2032</li>
<li>PIC16F57</li>
<li>4 botões de pressão SMD</li>
<li>Algumas resistências e condensadores no formato 0805:

<ul>
<li>5 x Resistência de 100 Ohm</li>
<li>2 x Resistência de 10K Ohm</li>
<li>1 x Resistência de 47K Ohm</li>
<li>1 x Condensador de 47p</li>
<li>1 x Condensador de 100n</li>
</ul></li>
<li>75 LEDS "0603" formato SMD</li>
<li>Adesivo de dupla face</li>
<li>PCB <a href="http://www.instructables.com/files/orig/F3O/SYDI/FKD1LQT8/F3OSYDIFKD1LQT8.pdf">pdf normal</a> <a href="http://www.instructables.com/files/orig/FEP/XX1D/FKD1HYN9/FEPXX1DFKD1HYN9.pdf">pdf invertido</a></li>
</ul>

<p>Para programar o micro-controlador foi usado o PICKit2.</p>

<h3>Soldar as partes</h3>

<p><img src="ArtigoMaker_3_FRUBQO7FKD1LQTC.jpg" alt="ArtigoMaker_3_FRUBQO7FKD1LQTC" />
<img src="ArtigoMaker_4_FJPHRU4FKD1LQTA.jpg" alt="ArtigoMaker_4_FJPHRU4FKD1LQTA" /></p>

<p>Proceder à soldagem de todas as partes começando pelas mas pequenas. Um par de pinças é útil para fixar o componente.
Tipicamente pode colocar-se um pouco de solda no "pad" da PCB e depois com o componente em cima e o ferro derreter novamente a solda para o componente ficar fixo.</p>

<p>Ter em atenção que os LEDs têm "polaridade"  e como tal apenas funciona de uma forma. Eventualmente para garantir a posição correta deverá testar-se um deles com um multimetro.</p>

<h3>Uma placa dupla face Ad-hoc</h3>

<p><img src="ArtigoMaker_5_FV92AWIFKD1LQT6.jpg" alt="ArtigoMaker_5_FV92AWIFKD1LQT6" /></p>

<p>Colocar algumas listas de fita invisível nos traços verticais da PCB junto a cada coluna de LEDs impede os fios que iremos soldar de tocarem nestes.</p>

<p>A seguir colocar um fio fino de cobre por cima de cada linha de LEDs para chegar até à resistência como na fotografia.
De notar que apenas são precisos 4 fios. A de topo não é necessária se for usada o desenho de PCB que foi providenciado.</p>

<h3>Programação do PIC16F57</h3>

<p><img src="ArtigoMaker_6_FLD7SICFKD1LQT5.jpg" alt="ArtigoMaker_6_FLD7SICFKD1LQT5" /></p>

<p>O próximo passo é por o programa no micro-controlador. Tudo o que precisa é um PIC KIT 2 programmer.
Descarregar o <a href="http://www.instructables.com/files/orig/F69/J3QC/FKD1LQTB/F69J3QCFKD1LQTB.zip">Código</a> e depois a partir do
IDE do MPLAB  abrir o ficheiro "main.asm". Pode alterar as mensagens guardadas (perto da linha 115 no código) para os seus dados.</p>

<p>A seguir selecione o "QuickBuild" e verifique que não há erros. Estamos prontos para enviar o código para o PIC.
Foi usada uma técnica simples de inserir uma linha de 5 pinos no programador e depois encostar estes ao PIC para programar.
Parece complicado mas como os processos de limpeza e escrita demoram cerca de 1 segundo é bastante rápido.</p>

<p>Atenção que a fotografia contem um erro e a seta do pino do fim do programador deve alinhar-se
com o pino de topo do PIC. Para programar deverá ser usada a ferramenta PICKIT2 uma vez que o MPLAB não suporta programar diretamente o PIC16F57.
Para fazer isto deverá especificar a família do PIC e o micro-controlador especifico 16F57, antes de carregar o ficheiro HEX criado nos passos anteriores
e finalmente programar o <em>chip</em>.</p>

<p>Se tudo tiver corrido corretamente, ao ser inserida a bateria os botões deverão funcionar.</p>

<h3>Finalização</h3>

<p><img src="ArtigoMaker_7.jpg" alt="ArtigoMaker_7" /></p>

<p>Para envolver o protótipo foi usada fita de duas camadas cortando o excesso. Depois foi colocada uma película transparente por cima dos botoes e leds.
A imagem carregada na película foi impressa em espelho para que a esta fique do lado de dentro do dispositivo.
Pode ser descarregada neste <a href="http://www.instructables.com/files/orig/FA7/VA40/FKD1LQT9/FA7VA40FKD1LQT9.pdf">link</a>.</p>

<p>Outros artigos/projetos interessantes de ler:</p>

<ul>
<li><a href="http://www.hackerbotlabs.com/2009/06/high-speed-coin-shrinking/">High Speed Coin Shrinking</a></li>
</ul>

<hr />

<h1 id="Compras">Compras <a href="#topo">^</a></h1>

<p>Artigos do <em>ebay</em> ou de outras lojas <em>online</em> que poderão ser úteis em projetos.</p>

<h2>8x8 8*8 3mm Dot Matrix Common Anode Red LED Display Module for Arduino Raspberry</h2>

<p>(<a href="http://www.ebay.co.uk/itm/230957669020">http://www.ebay.co.uk/itm/230957669020</a>) - US $1.55</p>

<p><img src="Compras_1.jpg" alt="Compras_1" /></p>

<p>Product Name:</p>

<p>8x8 3mm Dot-Matrix dia. Red LED Display New</p>

<h2>2pcs 0.36 inch 4 digit led display 7 seg segment Common cathode Red</h2>

<p>(<a href="http://www.ebay.co.uk/itm/201199391220">http://www.ebay.co.uk/itm/201199391220</a>) - US $2.43</p>

<p><img src="Compras_2.jpg" alt="Compras_2" /></p>

<p>Product Description</p>

<p>2pcs 0.36 inch 4 digit led display 7 seg segment Common cathode Red GOOD QUALITY</p>

<h2>5pcs MAX7219CNG MAX7219ENG MAX7219 DIP-24</h2>

<p>(<a href="http://www.ebay.co.uk/itm/301390022426">http://www.ebay.co.uk/itm/301390022426</a>) - £2.95</p>

<p><img src="Compras_3.jpg" alt="Compras_3" /></p>

<p>5pcs MAX7219CNG MAX7219ENG MAX7219 DIP-24</p>

<hr />

<p>That's all Folks!</p>

					</div>
				</section>
				</div> <!-- Container -->

				<footer id="footer" class="panel-footer">
					<div class="inner">
						<a href="https://github.com/PhileCMS/Phile">Phile</a> was made by <a href="https://github.com/PhileCMS">The PhileCMS Community</a>.
					</div>
				</footer>
			</div>
		</div>
</div>
		<script data-cfasync="false" src="../../../../../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-20725619-1']);
            _gaq.push(['_trackPageview']);
            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
		<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.altlab.org/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
	</body>
</html>
