<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

		<!-- <base href="https://altlab.org/d/" />  -->
		<title>Newsletter altLab - 2015-07-14 - Nº 11 | altLab Documenta</title>
				<meta name="description" content="Newsletters altLab Nº 11 de 14 de Julho de 2015">
				<meta property="og:type" content="article" />
		<meta property="og:title" content="Newsletter altLab - 2015-07-14 - Nº 11 | altLab Documenta" />
		<meta property="og:description" content="Newsletters altLab Nº 11 de 14 de Julho de 2015" />
		<meta property="og:url" content="https://altlab.org/d/m/jpralves/newsletters/2015/11/" />
		<meta property="og:site_name" content="altLab Documenta" />

		<!-- Bootstrap -->
		<link href="../../../../../themes/altlab/css/bootstrap.min.css" rel="stylesheet">
		<link href="../../../../../themes/altlab/override-test.css" rel="stylesheet">
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="../../../../../themes/altlab/js/jquery-1.12.4.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="../../../../../themes/altlab/js/bootstrap.min.js"></script>

	</head>
	<body>
<div class="container">
<div class="container-fluid">
      <div class="page-header hidden-xs" id="brand-logo">
        <h1><a href="../../../../../../index.html"><img src="../../../../../themes/altlab/altlab-logo-gradoverwhite.png" width="180" height="120" alt="Home" style="vertical-align:text-bottom" /></a> Documenta <span class="glyphicon glyphicon-leaf" style="color:#98ff98; padding-left:5px; top:2.8px;"></span></h1>

      </div>
			<nav class="navbar navbar-inverse">

				<div class="container-fluid">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#myNavbar">
							<span class="sr-only">Toggle navigation</span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
<div class="visible-xs">
<a class="navbar-brand" href="../../../../../../index.html"><img src="../../../../../themes/altlab/altlab-logo-documenta.png" width="58" height="35" alt="Home" style="margin-top: -7px;"></a>
						<a class="navbar-brand" href="../../../../../index.html">Documenta <span class="glyphicon glyphicon-leaf" style="color:#98ff98; padding-left:5px; top:2.8px;"></span></a></div>
					</div>
					<div class="collapse navbar-collapse" id="myNavbar">
						<ul class="nav navbar-nav">

           	<li id="dropdown.1" class="dropdown">
		<a class= "dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Membros <span class="caret"></span></a>
  
    <ul class="dropdown-menu">
<li>
<a href="../../../../index.html">Index</a>
</li>
   
           	<li id="dropdown.101" class="dropdown">
		<a href="../../../index.html">João Alves <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.102" class="dropdown">
		<a href="../../../../sislog/index.html">Fernando Carvalho <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.103" class="dropdown">
		<a href="../../../../pangelo/index.html">Pedro Ângelo <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.104" class="dropdown">
		<a href="../../../../dinix/index.html">Dinix <span class="caret"></span></a>
  
      	</li>
            	<li>
		<a href="../../../../funke/funke.html">m/funke/funke</a>
  
   	</li>
            	<li id="dropdown.106" class="dropdown">
		<a href="../../../../afonsom/index.html">Afonso Muralha <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.107" class="dropdown">
		<a href="../../../../x3msnake/index.html">X3msnake <span class="caret"></span></a>
  
      	</li>
            	<li>
		<a href="../../../../ampmendes/index.html">António Mendes</a>
  
   	</li>
            	<li>
		<a href="../../../../guardajoao/index.html">GuardaJoao</a>
  
   	</li>
            	<li>
		<a href="../../../../jac/index.html">JAC</a>
  
   	</li>
            	<li>
		<a href="../../../../nini/index.html">Nuno Nini</a>
  
   	</li>
 
</ul>
    	</li>
            	<li id="dropdown.2" class="dropdown">
		<a class= "dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Documentação Partilhada <span class="caret"></span></a>
  
    <ul class="dropdown-menu">
<li>
<a href="../../../../../s/index.html">Index</a>
</li>
   
                         	<li id="dropdown.203" class="dropdown">
		<a href="../../../../../s/workshops/index.html">Workshops <span class="caret"></span></a>
  
      	</li>
                   	<li>
		<a href="../../../../../s/documenta/index.html">Documenta DevMap</a>
  
   	</li>
                   	<li>
		<a href="../../../../../s/processos/index.html">Processos do Lab (draft)</a>
  
   	</li>
            	<li id="dropdown.208" class="dropdown">
		<a href="../../../../../s/recursos/index.html">Recursos <span class="caret"></span></a>
  
      	</li>
 
</ul>
    	</li>
 
						</ul>
					</div>
				</div>
			</nav>

			<div class="container">
				<div class="container">
				<section id="content">
					<div class="inner">
						<h1 id="topo"><img src="../res/__Titulo.png" alt="Newsletter altLab" /></h1>

<p>2015-07-14 - Nº 11</p>

<div id="google_translate_element"></div>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'pt', layout: google.translate.TranslateElement.FloatPosition.TOP_LEFT, multilanguagePage: true}, 'google_translate_element');
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<h1>Editorial</h1>

<p>Aqui está a Newsletter Nº 11 no seu formato habitual.</p>

<p>Esta Newsletter encontra-se mais uma vez disponível no sistema documenta do altLab.
Todas as Newsletters encontram-se indexadas no <a href="../../index.html">link</a>.</p>

<p>Esta Newsletter tem os seguintes tópicos:</p>

<ul>
<li><a href="#Novidades-da-Semana">Novidades da Semana</a></li>
<li><a href="#Ciencia-e-Tecnologia">Ciência e Tecnologia</a></li>
<li><a href="#Cursos-MOOC">Cursos MOOC</a></li>
<li><a href="#Modelos-3D">Modelos 3D</a></li>
<li><a href="#Open-Source">Open Source</a></li>
<li><a href="#Circuitos">Circuitos</a></li>
<li><a href="#Artigo-do-Maker">Artigo do Maker</a></li>
<li><a href="#Compras">Compras</a></li>
</ul>

<p>E chegou hoje a Plutão a sonda New Horizon (<a href="http://pluto.jhuapl.edu/Mission/The-Path-to-Pluto/Mission-Timeline.php">Mission Timeline</a>). Lançada em Janeiro de 2006 fez uma viagem de mais de 3 mil milhões de milhas (4,8 biliões de quilómetros). Irá agora recolher informação para posterior envio para a Terra, esta irá demorar cerca de 4 horas e meia a chegar!</p>

<p>Nesta edição da Newsletter iremos montar um circuito que tem o nome de "Atari Punk Console". Iremos igualmente falar do Audacity - software open-source para edição de ficheiros de áudio. O projeto de maker da semana é um mural interactivo com luz e som.</p>

<p><img src="../res/_jpralves.jpg" alt="jpralves" /> João Alves (<a href="https://altlab.org/d/m/jpralves/newsletters/2015/11/&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x6a;&#112;&#114;&#x61;&#108;&#118;&#x65;&#x73;&#64;g&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;o&#x6d;#x6d;&a&i&l&t&o&:&j&p&r&a&l&v&e&s&@g&m&a&i&l&.&co&m"><span class="__cf_email__" data-cfemail="741e04061518021107341319151d185a171b19">[email&#160;protected]</span></a>)</p>

<p>O conteúdo da Newsletter encontra-se sob a licença <img src="../res/_by-nc-sa4.0.png" alt="by-nc-sa4.0" /> <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>

<hr />

<h1 id="Novidades-da-Semana">Novidades da Semana <a href="#topo">^</a></h1>

<ul>
<li><p><a href="http://www.element14.com/community/community/news/blog/2015/06/29/samsung-researchers-nearly-double-lithium-ion-battery-capacity">Samsung Researchers Nearly Double Lithium-ion Battery Capacity</a></p>

<p><img src="NS11_SamsungResearchersNearlyDouble.jpg" alt="NS11_SamsungResearchersNearlyDouble" /></p>

<p><em>"Silicon is receiving considerable attention as an active material for next- generation lithium-ion battery anodes because of its gravimetric capacity--a measure in mAh/g of the total charge capacity stored by the cell or battery, per gram of the battery's weight. Unfortunately, the large volume change of silicon during charge–discharge cycles has in the past weakened its competitiveness. Recently, however, a research group from Samsung reported in the publication Nature Communications that using direct graphene growth over silicon nanoparticles without silicon carbide formation resulted in a near doubling of run-time by expanding energy density-- the amount of stored power in a given area -- to 1.8 times that of current batteries."</em></p></li>
<li><p><a href="http://www.nytimes.com/2015/07/09/technology/ibm-announces-computer-chips-more-powerful-than-any-in-existence.html">IBM announces 7nm chips breakthrough to keep Moore’s Law alive</a></p>

<p><img src="NS11_IbmAnnounces7NmChipsBreakthrou.jpg" alt="NS11_IbmAnnounces7NmChipsBreakthrou" /></p>

<p><em>"IBM said on Thursday that it had made working versions of ultradense computer chips, with roughly four times the capacity of today’s most powerful chips. The announcement, made on behalf of an international consortium led by IBM, the giant computer company, is part of an effort to manufacture the most advanced computer chips in New York’s Hudson Valley, where IBM is investing $3 billion in a private-public partnership with New York State, GlobalFoundries, Samsung and equipment vendors."</em></p></li>
<li><p><a href="http://mytechnologyworld9.blogspot.pt/2015/07/scientists-have-created-greenhouses.html">Scientists Have Created Greenhouses That Grow Gardens Underwater</a></p>

<p><img src="NS11_ScientistsHaveCreatedGreenhous.jpg" alt="NS11_ScientistsHaveCreatedGreenhous" /></p>

<p><em>"For the past 4 years a team of scientists off the coast of Italy have been working on a project called Nemo’s Garden. They're using special greenhouses underwater that allow them to grow fruits and vegetables 20 feet below the surface. The project still has a long way to go but it could be a giant leap forward when it comes to creating more food for the people of planet Earth."</em></p></li>
</ul>

<hr />

<h1 id="Ciencia-e-Tecnologia">Ciência e Tecnologia <a href="#topo">^</a></h1>

<ul>
<li><p><a href="http://sciconcilium.com/grapehene-for-artificial-skin/">Grapehene for Artificial Skin</a></p>

<p><img src="CT11_GrapeheneForArtificialSkin.jpg" alt="CT11_GrapeheneForArtificialSkin" /></p>

<p><em>"A pioneering new technique to produce high-quality, low cost graphene could pave the way for the development of the first truly flexible 'electronic skin', that could be used in robots. Researchers from the University of Exeter have discovered an innovative new method to produce the wonder material Graphene significantly cheaper, and easier, than previously possible."</em></p></li>
<li><p><a href="http://ucsdnews.ucsd.edu/pressrelease/electrical_engineers_break_power_and_distance_barriers_for_fiber_optic_comm">Electrical Engineers Break Power and Distance Barriers for Fiber Optic Communication</a></p>

<p><img src="CT11_ElectricalEngineersBreakPowerA.jpg" alt="CT11_ElectricalEngineersBreakPowerA" /></p>

<p><em>"Electrical engineers have broken key barriers that limit the distance information can travel in fiber optic cables and still be accurately deciphered by a receiver. Photonics researchers at the University of California, San Diego have increased the maximum power — and therefore distance — at which optical signals can be sent through optical fibers. This advance has the potential to increase the data transmission rates for the fiber optic cables that serve as the backbone of the internet, cable, wireless and landline networks."</em></p></li>
<li><p><a href="http://www.hzdr.de/db/Cms?pNid=99&amp;pOid=44906">With 300 Kilometers per Second to New Electronics</a></p>

<p><img src="CT11_With300KilometersPerSecondToNe.jpg" alt="CT11_With300KilometersPerSecondToNe" /></p>

<p><em>"A material with superfast electrons that exhibits extremely large magnetoresistance may be suitable for use in electronic components. It may be significantly easier to design electronic components in future. Scientists at the Max Planck Institute for Chemical Physics of Solids have discovered that the electrical resistance of a compound of niobium and phosphorus increases enormously when the material is exposed to a magnetic field. This giant magnetoresistance, which is responsible for the large storage capacity of modern hard discs, was previously known to occur in some complexly structured materials."</em></p></li>
</ul>

<hr />

<h1 id="Cursos-MOOC">Cursos MOOC <a href="#topo">^</a></h1>

<ul>
<li><a href="https://www.edx.org/course/signals-systems-part-2-iitbombayx-ee210-2x-0">Signals and Systems, Part 2</a> - Começa a 23 Julho.</li>
<li><a href="https://www.futurelearn.com/courses/creative-coding">Creative Coding</a> - Começa a 3 de Agosto.</li>
<li><a href="https://www.qut.edu.au/study/short-courses-and-professional-development/short-courses/introduction-to-robotics">Introduction to Robotics</a> - Começa a 10 de Agosto.</li>
<li><a href="https://novoed.com/venture1-2015-2">Technology Entrepreneurship</a> - Começa a 16 de Setembro.</li>
</ul>

<hr />

<h1 id="Modelos-3D">Modelos 3D <a href="#topo">^</a></h1>

<p>Com a disponibilidade de ferramentas que permitem dar azo a nossa imaginação na criação de peças 3D e espaços como o <a href="http://www.thingiverse.com/">thingiverse</a> para as publicar, esta rubrica apresenta alguns modelos selecionados que poderão ser úteis.</p>

<h2>Customizable Windmill (<a href="http://www.thingiverse.com/thing:924438">http://www.thingiverse.com/thing:924438</a>)</h2>

<p><img src="MP11_CustomizableWindmill.jpg" alt="Modelos3D_1_Customizable_Windmill" /></p>

<p>I designed this project with ease of printing in mind. Everything lays flat, and there shouldn't be many shallow angled overhangs.
I don't have access to a 3d printer right now, so the dimensions might be a bit strange, but that's why I made it customizable.</p>

<h2>Pythagoras Cup (The Greedy Cup) (<a href="http://www.thingiverse.com/thing:924398">http://www.thingiverse.com/thing:924398</a>)</h2>

<p><img src="MP11_PythagorasCupTheGreedyCup.jpg" alt="Modelos3D_2_Pythagoras_Cup" /></p>

<p>This is a very neat design that punishes the greedy! If the cup gets too full, the entire thing drains. Mechanically, it is a very simple siphon. A more complete (and cool) explanation on how this works can be found here: https://www.youtube.com/watch?v=ISfIT3B4y6E.</p>

<h2>Customizable Knob! (<a href="http://www.thingiverse.com/thing:54024">http://www.thingiverse.com/thing:54024</a>)</h2>

<p><img src="MP11_CustomizableKnob.jpg" alt="Modelos3D_3_Customizable_Knob" /></p>

<p>Design your own custom knobs!</p>

<p>Many different kinds are possible.</p>

<h2>Customizer Potentiometer Knobs (<a href="http://www.thingiverse.com/thing:41274">http://www.thingiverse.com/thing:41274</a>)</h2>

<p><img src="MP11_CustomizerPotentiometerKnobs.jpg" alt="Modelos3D_4_Customizer_Potentiometer_Knobs" /></p>

<p>Here's the customizer version of the OpenSCAD parametric potentiometer knob generator. Enjoy!</p>

<hr />

<h1 id="Open-Source">Open Source <a href="#topo">^</a></h1>

<h2>Audacity</h2>

<p><img src="OpenSource_Audacity.png" alt="OpenSource_Audacity" /></p>

<p>O software Open source da semana é o Audacity. Trata-se de um software que permite editar pistas de áudio em ambientes Windows, GNU/Linux e MAC OS X.
Encontra-se atualmente na versão 2.1.0 e pode ser descarrega da sua página oficial neste <a href="http://audacityteam.org/">link</a>.</p>

<p><img src="OpenSource_Audacity_screenshot.png" alt="OpenSource_Audacity_screenshot" /></p>

<p>As principais funcionalidades deste software são:</p>

<ul>
<li>Gravação

<ul>
<li>Gravar áudio ao vivo a partir de microfones, Linha de entrada, dispositivos USB/Firewire e outros</li>
<li>Gravar áudio reproduzido pelo computador em qualquer máquina Windows</li>
<li>Gravação temporizada e ativada por som</li>
<li>Dobragem por cima de pistas para criar gravações multi-pista</li>
<li>Gravar com muito baixa latência em dispositivos suportados em Linux pelo JACK</li>
<li>Gravar com amostragens até 192Khz. Em dispositivos de alta resolução suporte até 384 Khz.</li>
<li>Suporte de 24 bits em Windows</li>
<li>Gravação múltiplos canais em simultâneo</li>
<li>Apresentação de níveis de volume antes, durante e depois da gravação.</li>
</ul></li>
<li>Importação e Exportação

<ul>
<li>Converter cassetes e gravações em som digital ou CDs</li>
<li>Importa e exporta para ficheiro do formatos WAV, AIFF, FLAC e Ogg Vorbis</li>
<li>Importação "on-demand" de ficheiros WAV ou AIFF</li>
<li>Importa e exporta par a todos os formatos suportados pela bibilioteca libsndfile (GSM 6.10, 32-bit e 64-bit float WAV, RF64, e U/A-Law).</li>
<li>Suporte de formatos adicionais como AC3, M4A/M4R (AAC), WMA com biblioteca FFmpeg</li>
<li>Importação de MPEG áudio (MP2 e MP3) através da biblioteca libmad.</li>
<li>Exportar para MP3 com a biblioteca LAME encoder.</li>
<li>Criação de ficheiros WAV e AIFF preparados para serem gravados em CD de áudio.</li>
</ul></li>
<li>Qualidade Sonora

<ul>
<li>Suporta Samples de 16-bit, 24-bit e 32-bit</li>
<li>Rácios de amostragem e formatos são convertidos usando reamostragem de alta qualidade.</li>
<li>Pistas com diferentes rácios de amostragem são convertidas automaticamente em tempo real.</li>
</ul></li>
<li>Edição

<ul>
<li>Edição simples com funcionalidades de Corte, Copia, Colagem e Remoção</li>
<li>Undo sequencial ilimitado (com Redo) para andar para trás/frente qualquer numero de passos.</li>
<li>Edição e mistura de um grande numero de pistas.</li>
<li>As pistas podem ter etiquetas  com a funcionalidade de Pistas Sync-Lock</li>
<li>Ferramenta de desenho para alteração de pontos individuais de amostragem</li>
<li>Ferramenta de envelope para desvanecer-se o volume para cima ou para baixo suavemente.</li>
<li>Recuperação automática de Crashs no caso do programa terminar anormalmente</li>
</ul></li>
<li>Acessibilidade

<ul>
<li>Pistas e seleções podem ser feitas com o teclado</li>
<li>Grande numero de atalhos de teclado</li>
<li>Suporte para o JAWS, NVDA e outros leitores de écran</li>
</ul></li>
<li>Efeitos

<ul>
<li>Pré-visualização em tempo real de efeitos LADSPA, VST e Audio Unit (MAC OS X)</li>
<li>Mudança do <em>pitch</em> sem alteração do tempo (ou vice-versa)</li>
<li>Remoção da estática, zumbidos ou outros ruídos de fundo constantes</li>
<li>alteração de frequências com equalização, <em>Bass</em>, <em>Treble</em>, Filtros passa baixo/alto efeitos de filtro Notch.</li>
<li>Filtragem de seleção de frequências feito na vista do Espectrograma</li>
<li>Ajuste de volume com Compressão, Amplificação, Normalização, Desvanecimento, e efeitos ajustáveis de desvanecimento.</li>
<li>Remoção de Vocais de pistas estereo adequadas.</li>
<li>Criar voice-overs usando o <em>efeito Auto Duck</em> para <em>podcasts</em></li>
<li>Outros efeitos incluídos:</li>
<li>Eco</li>
<li>Paulstretch</li>
<li>Phaser</li>
<li>Ressonância (Reverb)</li>
<li>Reverso</li>
<li>Cortar Silencio</li>
<li>Wahwah</li>
<li>Executar vários efeitos num projeto ou em múltiplos ficheiros em modo <em>Batch Processing</em></li>
</ul></li>
<li>Plug-ins

<ul>
<li>Suporte para efeitos LADSPA, LV2, Nyquist, VST e Audio Unit</li>
<li>efeitos escritos na linguagem de programação Nyquist</li>
</ul></li>
<li>Analise

<ul>
<li>Modos de vista em espectrograma para visualizar e selecionar frequências</li>
<li>Janela "Plot Spectrum" para analise detalhada de frequências</li>
<li>"Sample Data Export" para exportar para um ficheiro contendo valores de amplitude para cada samples na seleção</li>
<li>Analise de contraste para analisar as medias das diferenças de volume RMS entre a voz e a música de fundo</li>
<li>suporte para adicionar plug-ins de analise VAMP</li>
</ul></li>
</ul>

<p>Links úteis:</p>

<ul>
<li><a href="https://wiki.audacityteam.org/wiki/Audacity_Wiki_Home_Page">Audacity Wiki</a></li>
<li><a href="http://manual.audacityteam.org/o/man/tutorials.html">Tutorials</a></li>
</ul>

<hr />

<h1 id="Circuitos">Circuitos <a href="#topo">^</a></h1>

<p>Aqui é apresentado um circuito simples que poderá ser construído com componentes.</p>

<h2>Atari Punk Console</h2>

<p><img src="Circuitos_1.jpg" alt="Circuitos_1" />
<img src="Circuitos_2.jpg" alt="Circuitos_2" /></p>

<p>O circuito apresentado é um circuito muito popular baseado em dois IC 555. Produz um conjunto de sons audiveis que podem ser alterados usando os dois potenciómetros.</p>

<p>O circuito original foi publicado por Forrest Mims num livro da Radio Shack "Engineer's Mini-Notebook - 555 Circuits".
Tinha o nome original de "Sound Synthesizer" que foi alterado posteriormente para o referido pela semelhança com o som produzido nos anos 80 pela consola Atari.
O circuito é um oscilador a-estável de uma onda quadrada que conduz um oscilador monoestável que cria um pulso simples (quadrado).
Existem dois controlos, um para a frequência do oscilador e outro para o comprimento do pulso.</p>

<h2>Esquemático</h2>

<p><img src="Circuitos_3_Schematics.png" alt="Circuitos_3_Schematics" /></p>

<h2>Componentes (BOM):</h2>

<ul>
<li>2x NE555P (U1, U2)</li>
<li>1x Resistência de 1K Ohms (R1)</li>
<li>1x Condensador Cerâmico de 10nF (C1)</li>
<li>1x Condensador Cerâmico de 100nF (C2)</li>
<li>1x Condensador Electrolítico de 10uF (C3)</li>
<li>3x Resistência Variável de 500K (VR1 a VR3)</li>
<li>1x Bateria de 9V</li>
<li>1x Cabo ligação Bateria</li>
</ul>

<h2>Pin-out dos IC</h2>

<p><img src="Circuitos_4_Pinout.png" alt="Circuitos_4_Pinout" /></p>

<p>Links úteis:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/555_timer_IC">555 timer IC</a></li>
<li><a href="http://web.media.mit.edu/~stefanm/HowTo/Electronics.html">Make something that blinks or makes sound. </a></li>
<li><a href="http://www.forrestmims.org/">Forrest M. Mims III</a></li>
<li><a href="http://www.aronnelson.com/gallery/main.php/v/seljer/album114/apclayout_copy.gif.html">Atari Punk Console with two 555s</a></li>
<li><a href="http://www.paulinthelab.com/2014/02/atari-punk-console-stripboard-veroboard.html">Atari Punk Console Stripboard Veroboard Layout</a></li>
</ul>

<hr />

<h1 id="Artigo-do-Maker">Artigo do Maker <a href="#topo">^</a></h1>

<p>Projeto interessante publicado por um maker.</p>

<h2>Interactive Spacelady Mural</h2>

<p>O projeto de maker da semana foi criado pela <a href="http://jdeboi.com/">Jenna Debois Blanc</a> e é um Mural Interactivo em formato de Mulher Espacial. Os detalhes do mesmo encontram-se publicados no <em>intructables</em> e no site da <a href="http://jdeboi.com/2015/07/spacelady/">Jenna</a>.</p>

<p><img src="ArtigoMaker_1_Interactive_Spacelady_Mural.jpg" alt="ArtigoMaker_1_Interactive_Spacelady_Mural" /></p>

<p>Este projeto desperta a atenção pela mistura de luz e som que provoca.</p>

<p>O Video publicado no <a href="https://youtu.be/kHBFIoMcDd8">youtube</a> mostra o projeto a funcionar. O projeto encontra-se publicado no <em>instructables</em> neste <a href="http://www.instructables.com/id/Interactive-Arduino-Mural/?ALLSTEPS">link</a>.</p>

<p>O projeto para ser executado precisa dos seguintes materiais:</p>

<ul>
<li>Arduino UNO + Cabo USB</li>
<li>Sensor de toque capacitivo</li>
<li>Neopixeis</li>
<li>Fita de cobre</li>
<li>Fita normal</li>
<li>Mini Breadbaord</li>
<li>Cabos de breadboard</li>
<li>Solda e ferro de soldar</li>
</ul>

<p>Relativamente aos Neopixeis é necessário algumas resistências entre o Arduino e o pino de dados. Ver o <a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/overview">Adafruit’s Neopixels uberguide</a> para mais detalhes.</p>

<h3>Passo 1: Preparar o astronauta</h3>

<p><img src="ArtigoMaker_2_1.jpg" alt="ArtigoMaker_2_1" />
<img src="ArtigoMaker_2_2.jpg" alt="ArtigoMaker_2_2" /></p>

<ol>
<li>Começar por fazer o mural com fita normal ( se tiver um projetor ajuda para se poder marcar os locais onde colocar a fita)</li>
<li>Usar 2 pregos para fixar o Arduino UNO à parece</li>
<li>Colocar a minibreadboard acima do Arduino com fita</li>
<li>Usar cabos de breadboard para ligar o Arduino ao sensor Capacitivo

<ul>
<li>5V -> Vin</li>
<li>GND -> GND</li>
<li>SCL -> A5 (no arduino)</li>
<li>SCA -> A4 (no arduino)</li>
</ul></li>
<li>Colocar 12 linhas de fita de cobre originarias de cada um dos 12 inputs do sensor capacitivo (0-11) que servirão como botões.

<ol>
<li>Soldar os cabos de breadboard ao fim de cada uma das fitas</li>
<li>Para fazer zonas de pressão facilmente premiveis, juntar a fita de cobre a volta de si para fazer uma forma</li>
</ol></li>
<li>Finalmente, colocar fita nas 2 strips de Neopixeis - 9 e 13 pixeis em comprimento ao fato do astronauta.

<ol>
<li>Nota: O numero de LEDs é arbitrário, mas se for usado o código abaixo, faça os ajustes necessários.</li>
<li>Os Neopixeis podem ser espaçados desde que sejam novamente unidos com fios de cobre.</li>
<li>Os Neopixeis foram ligados de acordo com o tutorial da adafruit que se encontra neste <a href="https://learn.adafruit.com/adafruit-neopixel-uberguide">link</a>.</li>
</ol></li>
</ol>

<h3>Passo 2: Código</h3>

<p>Antes de instalar o código no Arduino é necessário instalar duas bibliotecas:</p>

<ul>
<li><a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library">Adafruit Neopixel library</a></li>
<li><a href="https://learn.adafruit.com/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial/wiring">Adafruit Capacitive sensor library</a></li>
</ul>

<p>O código deste projeto encontra-se no github neste <a href="https://github.com/jdeboi/Spacelady">link</a>.</p>

<pre><code>/*********************************************************
SPACELADY
an interactive, Arduino-controlled Neopixel mural

June 2015
Jenna deBoisblanc
http://jdeboi.com


This code uses libraries and examples from Adafruit, specifically for
the MPR121 Breakout and Neopixels. Adafruit invests time and resources providing this open source code,
please support Adafruit and open-source hardware by purchasing
products from Adafruit! ----&gt; https://www.adafruit.com/products/

**********************************************************/
#include &lt;math.h&gt;
///////////////////////////////
// CAPACITIVE
#include &lt;Wire.h&gt;
#include "Adafruit_MPR121.h"
Adafruit_MPR121 cap = Adafruit_MPR121();
uint16_t lasttouched = 0;
uint16_t currtouched = 0;
int currentPressed = 0;
#define BOUNCE        0
#define PULSING       1
#define SPARKLES      2
#define WIPE          3
#define FILLUP        4
#define UNFILL        5
// rainbowCycle
#define RANDBRIGHT    6
#define BLOCKS        7
// rainbowBounce
#define END           8
int currentMode = 1;
long soundT = 0;
boolean firstSound = true;

///////////////////////////////
// NEOPIXELS
#include &lt;Adafruit_NeoPixel.h&gt;
#include &lt;avr/power.h&gt;
#define NEOPIN 2
#define NEOPIN2 3
#define NUMNEO 13
#define NUMNEO2 9
Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUMNEO, NEOPIN, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel strip2 = Adafruit_NeoPixel(NUMNEO2, NEOPIN2, NEO_GRB + NEO_KHZ800);
uint8_t currentWheelPos = 0;
uint32_t noteColors[4];
uint8_t notePositions[4] = {5, 54, 150, 230};
uint8_t noteBright[22];
boolean darkOn = false;
boolean sparkleOn = false;
int previousStart;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
void setup() {
  initializeColors();
  Serial.begin(9600);
  cap.begin(0x5A);
  strip.begin();
  strip2.begin();
  strip.show();
  strip2.show();
}

void loop() {
  updateKeys();                      // update key positions
  checkPresses();                    // any keys pressed?
  if(currentMode != WIPE &amp;&amp; currentMode != FILLUP &amp;&amp; currentMode != UNFILL &amp;&amp; currentMode != BLOCKS &amp;&amp; currentMode != END) {
    if(allKeysOff()) setAllPixels(0);  // reset Neopixels if no presses
  }
}
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

///////////////////////////////
// PROGRAM LOGIC

void checkPresses() {
  int pins[] = {10,7,6,9,8,5,1,0,3,2,4};
  if(keyPressed(pins[4])) shiftMode();    // change mode button
  else if(currentMode == END) {
    for(int k=6; k&lt;10; k++) {
      if(keyPressed(pins[k])) {
        if(k==9) {
          pulseOut(noteColors[k-6],10);
          return;
        }
        else {
          fadeIn(noteColors[k-6], 10);
          break;
        }
      }
      else if(keyReleased(pins[k])) {
        if(k != 9) fadeOut(noteColors[k-6],10);
        break;
      }
    }
  }
  else if (currentMode == FILLUP || currentMode == UNFILL) {
    for(int k=0; k&lt;4; k++) {
      if(keyPressed(pins[k])) {
        if(currentMode == FILLUP) fillUpColorKey(k,50);
        else unFillColorKey(k,50);
        break;
      }
    }
    for(int k=5; k&lt;10; k++) {
      if(keyPressed(pins[k])) {
        if(currentMode == FILLUP) fillUpColorKey(k-1,50);
        else unFillColorKey(k-1,50);
        break;
      }
    }
  }
  else {
    // "Space, space lady..."
    if(keyPressed(pins[0])) playSound(0);
    else if(keyPressed(pins[1])) playSound(1);
    else if(keyPressed(pins[2])) playSound(2);

    // control buttons
    else if(keyPressed(pins[3])) {
      while(1) rainbowCycleOrig(0);
    }
    // rainbow buttons
    else if(keyPressed(pins[5])) rainbowBounce(30);
    else if(keyPressed(pins[10])) rainbowCycle(5);

    // color keys
    for(int k=6; k &lt; 10; k++) {
      if(keyPressed(pins[k])) {
        playColor(k-6);
        break;
      }
    }
  }
}

void shiftMode() {
  currentMode++;
  //Serial.print("mode: "); Serial.println(currentMode);
  if(currentMode == 0) {
    strip.setBrightness(150);
    strip2.setBrightness(150);
  }
  else if(currentMode &gt; 8) currentMode = 0;
}

void playColor(int key) {
  switch(currentMode) {
    case BOUNCE:
      //Serial.println("bounce!");
      bounce(noteColors[key],key, 25);
      break;
    case PULSING:
      //Serial.println("pulse!");
      pulse(noteColors[key],key, 5);
      break;
    case SPARKLES:
      //Serial.println("sparkles!");
      theaterChaseDouble(key, 50);
      break;
    case WIPE:
      //Serial.println("wipe!");
      colorWipe(noteColors[key],key,20);
      break;
    case RANDBRIGHT:
      //Serial.println("random brightness!");
      randomBrightRamp(key, 5);
      break;
    case BLOCKS:
      //Serial.println("wipe!");
      blocks(key);
      break;
  }
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

///////////////////////////////
// CAPACITIVE

boolean keyPressed(int num) {
  if ((currtouched &amp; _BV(num)) &amp;&amp; !(lasttouched &amp; _BV(num)) ) {
    //Serial.println(num);
    return true;
  }
  return false;
}

boolean keyReleased(int num) {
   if (!(currtouched &amp; _BV(num)) &amp;&amp; (lasttouched &amp; _BV(num)) ) {
     // Serial.print("released: "); Serial.println(num);
     return true;
   }
   return false;
}

boolean allKeysOff() {
  for(int i = 0; i &lt; 11; i++) {
    if (currtouched &amp; (1 &lt;&lt; i)) return false;
  }
  return true;
}

void updateKeys() {
  lasttouched = currtouched;
  currtouched = cap.touched();
}

boolean colorKeyUp(uint8_t k) {
  // 0,1,2,3,4,5,6,7,8,9,10
  //10,7,6,9,8,5,1,0,3,2,4
  int pins[] = {1,0,3,2,5,4};
  if (!(cap.touched() &amp; (1 &lt;&lt; pins[k]))) return true;
  return false;
}

void checkSound() {
  int pins[] = {10, 7, 6};
  uint16_t temp = cap.touched();
  for(int i = 0; i &lt; 3; i++) {
    if ((temp &amp; _BV(pins[i])) &amp;&amp; !(lasttouched &amp; _BV(pins[i])) ) {
      //Serial.print("Playing sound "); Serial.println(i);
      playSound(i);
      return;
    }
  }
}

void soundDelay(uint16_t timeDelay) {
  long t = millis();
  while(millis() - t &lt; timeDelay) checkSound();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

///////////////////////////////
// NEOPIXELS
void setNeopixel(int index, uint32_t col) {
  if(index &lt; strip2.numPixels() &amp;&amp; index &gt;= 0) {
    strip2.setPixelColor(strip2.numPixels()-1-index, col);
  }
  else if(index &gt; strip2.numPixels()-1 &amp;&amp; index &lt; strip2.numPixels()+strip.numPixels()) {
    strip.setPixelColor(index - strip2.numPixels(), col);
  }
}

uint32_t getNeopixelColor(int index) {
  if(index &lt; strip2.numPixels() &amp;&amp; index &gt;= 0) {
    return strip2.getPixelColor(strip2.numPixels()-1-index);
  }
  else if(index &gt; strip2.numPixels()-1 &amp;&amp; index &lt; strip2.numPixels()+strip.numPixels()) {
    return strip.getPixelColor(index - strip2.numPixels());
  }
}

void setAllPixels(uint32_t col) {
  for(uint16_t i=0; i&lt;strip.numPixels(); i++) {
    strip.setPixelColor(i, col);
  }
  for(uint16_t i=0; i&lt;strip2.numPixels(); i++) {
    strip2.setPixelColor(i, col);
  }
  strip.show();
  strip2.show();
}

void setPixelBrightness(uint8_t index, uint8_t r, uint8_t g, uint8_t b, uint8_t bright) {
  double hslArray[3];
  int rgbArray[3];
  rgb2HSL(r,g,b, hslArray);
  double lum = bright/256.0;
  hslArray[2]= lum;
  Serial.print("lum: " ); Serial.println(hslArray[2]);
  hsl2RGB(hslArray[0], hslArray[1], hslArray[2], rgbArray);
  setNeopixel(index, strip.Color(rgbArray[0],rgbArray[1],rgbArray[2]));
}

void setPixelBrightness(uint8_t index, uint32_t col, uint8_t bright) {
  byte r = byte(col &gt;&gt; 16);
  byte g = byte(col &gt;&gt; 8);
  byte b = byte(col);
  double hslArray[3];
  int rgbArray[3];
  rgb2HSL(r,g,b, hslArray);
  double lum = bright/256.0;
  hslArray[2]= lum;
  hsl2RGB(hslArray[0], hslArray[1], hslArray[2], rgbArray);
  setNeopixel(index, strip.Color(rgbArray[0],rgbArray[1],rgbArray[2]));
}

void rainbowMix(int key, uint8_t timeDelay) {
  if(key &lt; 4) {
    int range = 256/8-10;
    int startVal = key*256/8;
    int endVal = startVal + range;
    uint16_t i, j;

    for(j=startVal; j&lt;endVal; j++) {
      if(colorKeyUp(key)) return;
      for(i=0; i&lt; strip.numPixels(); i++) {
        strip.setPixelColor(i, Wheel(((i * range / strip.numPixels()) + j) &amp; 255));
      }
      for(i=0; i&lt; strip2.numPixels(); i++) {
        strip2.setPixelColor(i, Wheel(((i * range / strip2.numPixels()) + j) &amp; 255));
      }
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
    }
    for(j=endVal; j&gt;startVal; j--) {
      if(colorKeyUp(key)) return;
      for(i=0; i&lt; strip.numPixels(); i++) {
        strip.setPixelColor(i, Wheel(((i * range / strip.numPixels()) + j) &amp; 255));
      }
      for(i=0; i&lt; strip2.numPixels(); i++) {
        strip2.setPixelColor(i, Wheel(((i * range / strip2.numPixels()) + j) &amp; 255));
      }
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
    }
  }
  else {}
}

void fillUpColorKey(uint8_t key, uint8_t timeDelay) {
  strip.clear();
  strip2.clear();
  int totalNeo = strip.numPixels() + strip2.numPixels();
  float fillPixNum = (totalNeo)/8;  // number of pixels per fill
  int startPix = int((key*1.0) * fillPixNum);
  int endPix = int((key+1.0) * fillPixNum);
  int wheelInc = int(256.0/totalNeo);
  //Serial.println(wheelInc);
  int startInc = 0;
  for(int i = 0; i &lt; startPix; i++) {
    setNeopixel(i, Wheel(wheelInc*i + startInc));
  }
  if(key == 7) {
    for(int i = startPix; i &lt; endPix+1; i++) {
      setNeopixel(i, Wheel(wheelInc*i + startInc));
      strip.show();
      strip2.show();
      delay(timeDelay);
    }
  }
  else if(key == 8) {
    for(int i = startPix; i &lt; totalNeo; i++) {
      setNeopixel(i, Wheel(wheelInc*i + startInc));
      strip.show();
      strip2.show();
      delay(timeDelay);
    }
  }
  else {
    for(int i = startPix; i &lt;= endPix; i++) {
      setNeopixel(i, Wheel(wheelInc*i + startInc));
      strip.show();
      strip2.show();
      delay(timeDelay);
    }
  }
}

void unFillColorKey(uint8_t key, uint8_t timeDelay) {
  int totalNeo = strip.numPixels() + strip2.numPixels();
  float fillPixNum = (totalNeo)/7;  // number of pixels per fill
  int startPix = int((key)* 1.0 * fillPixNum);
  int endPix = int((key+1.0) * fillPixNum);
  int wheelInc = int(256.0/totalNeo);
  int startInc = 0;
  for(int i = 0; i &lt; totalNeo; i++) setNeopixel(i, Wheel(wheelInc*i + startInc));  // all on
  if (key == 8) {
    strip.show();
    strip2.show();
  }
  else {
    for(int i = totalNeo - 1; i &gt; endPix; i--) setNeopixel(i, 0);
    for(int i = endPix; i &gt;= startPix; i--) {
      setNeopixel(i, 0);
      strip.show();
      strip2.show();
      delay(timeDelay);
    }
  }
}

void lightening(uint32_t col,uint8_t key, uint8_t timeDelay) {
  setAllPixels(0);
  while(!colorKeyUp(key)) {
    checkSound();
    for(int i = 22; i &gt;= -5; i--) {
      if(colorKeyUp(key)) return;
      for(int j = 0; j &lt; 5; j++) {
        setNeopixel(i, col);
      }
      setNeopixel(i+5, 0);
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
    }
  }
}

void rainbowLightening(int timeDelay) {
  setAllPixels(0);
  for(int i = 22; i &gt;= -5; i--) {
    if(colorKeyUp(4)) break;
    setNeopixel(i, Wheel(240));
    setNeopixel(i+1, Wheel(200));
    setNeopixel(i+2, Wheel(150));
    setNeopixel(i+3, Wheel(100));
    setNeopixel(i+4, Wheel(50));
    setNeopixel(i+5, 0);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
}

void pulse(uint32_t col, int key, int timeDelay) {
  while(!colorKeyUp(key)) {
    fadeIn(col, timeDelay);
    fadeOut(col, timeDelay);
  }
  strip.setBrightness(150);
  strip2.setBrightness(150);
}

void pulseOut(uint32_t col, int timeDelay) {
  uint8_t totalNeo = strip.numPixels() + strip2.numPixels();
  uint8_t wheelInc = int(256.0/totalNeo);
  for(int i = 0; i &lt; 4; i++) {
    fadeInRainbow(timeDelay);
    fadeOutRainbow(timeDelay);
    timeDelay+=5;
  }
  strip.setBrightness(0);
  strip2.setBrightness(0);
  strip.show();
  strip2.show();
  delay(1500);
}

void bounce(uint32_t col, uint8_t key, uint8_t timeDelay) {
  setAllPixels(0);
  while(!colorKeyUp(key)) {
    for(int i = 17; i &gt;= 0; i--) {
      if(colorKeyUp(key)) return;
      for(int j=0; j&lt;5; j++) {
        setNeopixel(i+j, col);
      }
      setNeopixel(i+5,0);
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
    }
    for(int i = 0; i &lt;18; i++) {
      if(colorKeyUp(key)) return;
      setNeopixel(i-1, 0);
      for(int j=0; j&lt;5; j++) {
        setNeopixel(i+j, col);
      }
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
    }
  }
}

void rainbowBounce(int timeDelay) {
  setAllPixels(0);
  while(!colorKeyUp(4)) {
    for(int i = 17; i &gt;= 0; i--) {
      setNeopixel(i, Wheel(240));
      setNeopixel(i+1, Wheel(200));
      setNeopixel(i+2, Wheel(150));
      setNeopixel(i+3, Wheel(100));
      setNeopixel(i+4, Wheel(50));
      setNeopixel(i+5, 0);
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
      if(colorKeyUp(4)) return;
    }
    for(int i = 0; i &lt;16; i++) {
      setNeopixel(i, Wheel(240));
      setNeopixel(i+1, Wheel(200));
      setNeopixel(i+2, Wheel(150));
      setNeopixel(i+3, Wheel(100));
      setNeopixel(i+4, Wheel(50));
      setNeopixel(i-1, 0);
      strip.show();
      strip2.show();
      long t = millis();
      soundDelay(timeDelay);
      if(colorKeyUp(4)) return;
    }
  }
}

void neopixelsNext(int i) {
  if(currentPressed == i) setAllPixels(Wheel(currentWheelPos));
  else {
    currentWheelPos += 13;
    setAllPixels(Wheel(currentWheelPos));
  }
  currentPressed = i;
}

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t key, uint8_t timeDelay) {
  int n;
  if(strip.numPixels() &gt; strip2.numPixels()) n = strip.numPixels();
  else n = strip2.numPixels();
  for(uint16_t i=0; i&lt;n; i++) {
    strip.setPixelColor(i, c);
    strip2.setPixelColor(i, c);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
}

void fadeIn(uint32_t col, int timeDelay) {
  for(int i = 0; i &lt; 200; i+=15) {
    setAllPixels(col);
    strip.setBrightness(i);
    strip2.setBrightness(i);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
}

void fadeInRainbow(int timeDelay) {
  int totalNeo = strip.numPixels() + strip2.numPixels();
  int wheelInc = int(256.0/totalNeo);
  for(int i = 0; i &lt; 200; i+=15) {
    for(int i = 0; i &lt; totalNeo-1; i++) setNeopixel(i, Wheel(wheelInc*i));
    strip.setBrightness(i);
    strip2.setBrightness(i);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
}

void fadeOut(uint32_t col, int timeDelay) {
  for(int i = 200; i &gt;= 0; i-=15) {
    setAllPixels(col);
    strip.setBrightness(i);
    strip2.setBrightness(i);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
  strip.setBrightness(0);
  strip2.setBrightness(0);
  strip.show();
  strip2.show();
  soundDelay(timeDelay);
}

void fadeOutRainbow(int timeDelay) {
  int totalNeo = strip.numPixels() + strip2.numPixels();
  int wheelInc = int(256.0/totalNeo);
  for(int i = 200; i &gt;= 0; i-=15) {
    for(int i = 0; i &lt; totalNeo-1; i++) setNeopixel(i, Wheel(wheelInc*i));
    strip.setBrightness(i);
    strip2.setBrightness(i);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
  strip.setBrightness(0);
  strip2.setBrightness(0);
  strip.show();
  strip2.show();
  soundDelay(timeDelay);
}

void rainbow(uint8_t timeDelay) {
  uint16_t i, j;
  for(j=0; j&lt;256; j++) {
    for(i=0; i&lt;strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel((i+j) &amp; 255));
    }
    for(i=0; i&lt;strip2.numPixels(); i++) {
      strip2.setPixelColor(i, Wheel((i+j) &amp; 255));
    }
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
}

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t timeDelay) {
  uint16_t i, j;
  //for(j=0; j&lt;256*2; j++) { // 5 cycles of all colors on wheel
  while(!colorKeyUp(5)) {
    for(j=0; j&lt;256; j++) {
      for(i=0; i&lt; strip.numPixels(); i++) {
        strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) &amp; 255));
      }
      for(i=0; i&lt; strip2.numPixels(); i++) {
        strip2.setPixelColor(i, Wheel(((i * 256 / strip2.numPixels()) + j) &amp; 255));
      }
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
      if(colorKeyUp(5)) return;
    }
  }
}

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycleOrig(uint8_t timeDelay) {
  uint16_t i, j;
  for(j=0; j&lt;256*5; j++) { // 5 cycles of all colors on wheel
      for(i=0; i&lt; strip.numPixels(); i++) {
        strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) &amp; 255));
      }
      for(i=0; i&lt; strip2.numPixels(); i++) {
        strip2.setPixelColor(i, Wheel(((i * 256 / strip2.numPixels()) + j) &amp; 255));
      }
      strip.show();
      strip2.show();
      delay(timeDelay);
    }

}

void randomLights(uint8_t key, uint8_t timeDelay) {
  uint8_t startval, endval;
  startval = previousStart + 96;
  endval = startval + 50;
  startval= (key-2)*64;
  endval = startval + 50;

  int cycle = 0;
  while(!colorKeyUp(key)) {
    uint8_t randPix = random(strip.numPixels() + strip2.numPixels());
    uint32_t randColor = Wheel((random(startval, endval))%255);
    uint8_t randBrightness;
    if(cycle%4 == 1) randBrightness = 0;
    else if (cycle%4 == 2) randBrightness = random(5,15);
    else if (cycle%4 == 3) randBrightness = random(50,100);
    else randBrightness = random(100,150);
    //setNeopixel(randPix, randColor);
    setPixelBrightness(randPix,randColor, randBrightness);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
    cycle++;
  }
  previousStart = startval;
}

//Theatre-style crawling lights with 2 colors
void theaterChaseDouble(uint8_t k, uint8_t timeDelay) {
  while(!colorKeyUp(k)) {
    for (int q=0; q &lt; 3; q++) {
      for (int i=0; i &lt; strip.numPixels(); i=i+3) {
        //if(i%2 == 0) strip.setPixelColor(i+q, noteColors[k]);
        //else strip.setPixelColor(i+q, noteColors[(k+1)%4]);
        strip.setPixelColor(i+q, noteColors[k]);
      }
      for (int i=0; i &lt; strip2.numPixels(); i=i+3) {
        //if(i%2 == 0) strip2.setPixelColor(i+q, noteColors[k]);
        //else strip2.setPixelColor(i+q, noteColors[(k+1)%4]);
        strip2.setPixelColor(i+q, noteColors[k]);
      }
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
      for (int i=0; i &lt; strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
      }
      for (int i=0; i &lt; strip2.numPixels(); i=i+3) {
        strip2.setPixelColor(i+q, 0);
      }
    }
  }
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t timeDelay) {
  for (int j=0; j&lt;10; j++) {  //do 5 cycles of chasing
    for (int q=0; q &lt; 3; q++) {
      for (int i=0; i &lt; strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, c);    //turn every third pixel on
      }
      for (int i=0; i &lt; strip2.numPixels(); i=i+3) {
        strip2.setPixelColor(i+q, c);
      }
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
      for (int i=0; i &lt; strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
      }
      for (int i=0; i &lt; strip2.numPixels(); i=i+3) {
        strip2.setPixelColor(i+q, 0);
      }
    }
  }
}

//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint8_t timeDelay) {
  for (int j=0; j &lt; 256; j++) {     // cycle all 256 colors in the wheel
    for (int q=0; q &lt; 3; q++) {
      for (int i=0; i &lt; strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
      }
      for (int i=0; i &lt; strip2.numPixels(); i=i+3) {
        strip2.setPixelColor(i+q, Wheel( (i+j) % 255));
      }
      strip.show();
      strip2.show();
      soundDelay(timeDelay);
      for (int i=0; i &lt; strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
      }
      for (int i=0; i &lt; strip.numPixels(); i=i+3) {
        strip2.setPixelColor(i+q, 0);        //turn every third pixel off
      }
    }
  }
}

void randomBrightRamp(uint8_t k, uint8_t timeDelay) {
  uint8_t b[] = {10, 30, 80, 150};
  strip.setBrightness(b[k]);
  strip2.setBrightness(b[k]);
  for(int i = 0; i &lt; strip.numPixels() + strip2.numPixels(); i++) {
    uint32_t randColor = Wheel(random(0,255));
    setNeopixel(i, randColor);
  }
  strip.show();
  strip2.show();
  while(!colorKeyUp(k)) {
    uint32_t randColor = Wheel(random(0, 255));
    uint8_t pix = random(0, strip.numPixels() + strip2.numPixels());
    //setNeopixel(pix, randColor);
    strip.show();
    strip2.show();
    soundDelay(timeDelay);
  }
  strip.setBrightness(150);
  strip2.setBrightness(150);
}

void blocks(uint8_t k) {
  for(int i = 0; i &lt; 22; i++) {
    if (k == 0) setNeopixel(i, noteColors[0]);
    else if (k == 1) {
      if(i &lt; 9) setNeopixel(i, noteColors[0]);
      else setNeopixel(i, noteColors[1]);
    }
    else if (k == 2) {
      if(i &lt; 4) setNeopixel(i, noteColors[0]);
      else if (i &lt; 9) setNeopixel(i, noteColors[1]);
      else if (i &lt; 15) setNeopixel(i, noteColors[2]);
      else setNeopixel(i, noteColors[3]);
    }
    else {
      setNeopixel(i, noteColors[(i/3)%4]);
    }
  }
  strip.show();
  strip2.show();
}

void set4Blocks() {
  for(int i = 0; i &lt; 22; i++) {
    setNeopixel(i, noteColors[i/5]);
  }
}

void set48locks() {
  for(int i = 0; i &lt; 22; i++) {
    setNeopixel(i, noteColors[i/5]);
  }
}

void fade(uint32_t col1, uint32_t col2, uint8_t timeDelay) {
  double h1, h2;
  double l = .5;
  double s = 1;
  double hsl[3];
  rgb2HSL(byte(col1 &gt;&gt; 16), byte(col1 &gt;&gt; 8), byte(col1), hsl);
  h1 = hsl[0];
  s = hsl[1];
  l = hsl[2];
  Serial.print("HSL h1: "); Serial.println(h1);
  rgb2HSL(byte(col2 &gt;&gt; 16), byte(col2 &gt;&gt; 8), byte(col2), hsl);
  h2 = hsl[0];
  Serial.print("HSL h2: "); Serial.println(h2);
  if(h2 &gt; h1) {
    float inc = (h2 - h1)/10.0;
    while (h2 &gt; h1) {
      h1+=inc;
      //Serial.print("h1: "); Serial.println(h1);
      int rgb[3];
      hsl2RGB(h1, s, l, rgb);
      setAllPixels(strip.Color(rgb[0], rgb[1], rgb[2]));
      Serial.print(rgb[0]); Serial.print(" ");
      Serial.print(rgb[1]); Serial.print(" ");
      Serial.println(rgb[2]);
      strip.show();
      soundDelay(timeDelay);
    }
  }
  else {
    double inc = (h1 - h2)/10.0;
    Serial.print("Inc: "); Serial.println(inc);
    while (h2 &lt; h1) {
      h1-=inc;
      Serial.print("h-1: "); Serial.println(h1);
      int rgb[3];
      hsl2RGB(h1, s, l, rgb);
      strip.show();
      setAllPixels(strip.Color(rgb[0], rgb[1], rgb[2]));
      delay(timeDelay);
      //Serial.print(rgb[0]); Serial.print(" ");
      //Serial.print(rgb[1]); Serial.print(" ");
      //Serial.println(rgb[2]);
    }
  }

}

// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  if(WheelPos &lt; 85) {
   return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  } else if(WheelPos &lt; 170) {
    WheelPos -= 85;
   return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  } else {
   WheelPos -= 170;
   return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  }
}

void colorShift() {
  for(int i = 0; i &lt; 4; i++) {
    notePositions[i] = (notePositions[i]+15)%255;
    noteColors[i] = Wheel(notePositions[i]);
  }
}

void shiftPosForward(uint8_t steps) {
  uint8_t totNeo = strip.numPixels() + strip2.numPixels();
  for(int i = 0; i &lt; steps; i++) {
    uint32_t temp = getNeopixelColor(totNeo-1);
    for(int i = totNeo-1; i &gt; 0; i--) {
      setNeopixel(i,getNeopixelColor(i-1));
    }
    setNeopixel(0,temp);
  }
}



void shiftPosBack(uint8_t steps) {
  uint8_t totNeo = strip.numPixels() + strip2.numPixels();
  for(int i = 0; i &lt; steps; i++) {
    int temp = getNeopixelColor(0);
    for(int i = 0; i &lt; totNeo-1; i++) {
      setNeopixel(i, getNeopixelColor(i+1));
    }
    setNeopixel(totNeo-1,temp);
  }
}

void shiftBright() {
  int temp = noteBright[21];
  for(int i = 21; i &gt; 0; i--) {
    noteBright[i] = noteBright[i-1];
  }
  noteBright[0] = temp;
}

void initializeColors() {
  for(int i = 0; i &lt; 4; i++) noteColors[i] = Wheel(notePositions[i]);
}

void rgb2HSL (uint8_t red, uint8_t green, uint8_t blue, double *a){
  double r = red/255.0;
  double g = green/255.0;
  double b = blue/255.0;
  double v;
  double m;
  double vm;
  double r2, g2, b2;
  double h = 0; // default to black
  double s = 0;
  double l = 0;

  v = max(r,g);
  v = max(v,b);
  m = min(r,g);
  m = min(m,b);
  l = (m + v) / 2.0;
  if (l &lt;= 0.0) return;

  vm = v - m;
  s = vm;
  if (s &gt; 0.0) s /= (l &lt;= 0.5) ? (v + m ) : (2.0 - v - m);
  else return;

  r2 = (v - r) / vm;
  g2 = (v - g) / vm;
  b2 = (v - b) / vm;
  if (r == v) h = (g == m ? 5.0 + b2 : 1.0 - g2);
  else if (g == v) h = (b == m ? 1.0 + r2 : 3.0 - b2);
  else h = (r == m ? 3.0 + g2 : 5.0 - r2);
  h /= 6.0;
  a[0] = h;
  a[1] = s;
  a[2] = l;
}

void hsl2RGB(float H, float S, float L, int *a) {
  uint8_t r = 0;
  uint8_t g = 0;
  uint8_t b = 0;
    if(S == 0) {
      r = L;
      g = L;
      b = L;
    }
    else {
      float temp1 = 0;
      if(L &lt; .50) {
        temp1 = L*(1 + S);
      }
      else {
        temp1 = L + S - (L*S);
      }
      float temp2 = 2*L - temp1;
      float temp3 = 0;
      for(int i = 0 ; i &lt; 3 ; i++) {
        switch(i) {
          case 0: { //red
            temp3 = H + .33333f;
            if(temp3 &gt; 1) temp3 -= 1;
            hsl_Subfunction(r,temp1,temp2,temp3);
        break;
      }
      case 1: { // green
        temp3 = H;
        hsl_Subfunction(g,temp1,temp2,temp3);
        break;
      }
      case 2: { // blue
        temp3 = H - .33333f;
        if(temp3 &lt; 0)
            temp3 += 1;
        hsl_Subfunction(b,temp1,temp2,temp3);
        break;
      }
      default:{}
    }
    }
  }
  a[0] = (uint8_t)((((float)r)/100)*255);
  a[1] = (uint8_t)((((float)g)/100)*255);
  a[2] = (uint8_t)((((float)b)/100)*255);
  Serial.print("RGB: ");
  Serial.print(a[0]); Serial.print(" ");
  Serial.print(a[1]); Serial.print(" ");
  Serial.print(a[2]); Serial.println(" ");
}

// This is a subfunction of HSLtoRGB
void hsl_Subfunction(uint8_t&amp; c, const float&amp; temp1, const float&amp; temp2, const float&amp; temp3) {
  if((temp3 * 6) &lt; 1) c = (unsigned int)((temp2 + (temp1 - temp2)*6*temp3)*100);
  else {
    if((temp3 * 2) &lt; 1) c = (unsigned int)(temp1*100);
    else {
      if((temp3 * 3) &lt; 2) c = (unsigned int)((temp2 + (temp1 - temp2)*(.66666 - temp3)*6)*100);
      else c = (unsigned int)(temp2*100);
    }
   }
  return;
}

void soundShift() {
  firstSound =! firstSound;
}

void playSound(byte key) {
  if(millis() - soundT &gt; 100) {
    if(firstSound) Serial.write(key);
    else Serial.write(key+3);
    soundT = millis();
  }
}
</code></pre>

<p>Se quiser que o projeto tenha som associado aos botões é necessário instalar o <em>processing</em>. No mesmo repositório encontra-se uma pasta designada por "SoundPlayer" que tem o código que deve executar no processing. É necessário configurar corretamente a porta Série do equipamento no código do SoundPlayer. O resultado é que o PC irá tocar sons quando os botões forem acionados. Para mudar os sons basta alterar os ficheiros <em>0-11.wav</em> que se encontram na mesma pasta.</p>

<p>O resultado final é este:</p>

<p><img src="ArtigoMaker_3.jpg" alt="ArtigoMaker_3" /></p>

<p>Outros artigos/projetos interessantes de ler:</p>

<ul>
<li><a href="http://bitlog.it/re/old-school-eprom-firmware-dumping/">Dumping Old PROMs With New Hardware</a></li>
<li><a href="http://www.open-electronics.org/the-power-of-arduino-this-unknown/">The power of Arduino, this unknown ...</a></li>
<li><a href="http://www.instructables.com/id/Arduino-DCF77-Master-Wall-Clock/">Arduino DCF77 Master Wall Clock</a></li>
<li><a href="http://hackaday.com/2015/07/06/stenography-yes-with-arduinos/">Stenography (Yes, with Arduinos)</a></li>
</ul>

<hr />

<h1 id="Compras">Compras <a href="#topo">^</a></h1>

<p>Artigos do <em>ebay</em> ou de outras lojas <em>online</em> que poderão ser úteis em projetos.</p>

<h2>6 New B500k Split Shaft Guitar Potentiometer Pots Audio Tone Switch Control</h2>

<p>(<a href="http://www.ebay.co.uk/itm/141157845435">http://www.ebay.co.uk/itm/141157845435</a>) - £1.02</p>

<p><img src="Compras_1.jpg" alt="Compras_1" /></p>

<p>Description</p>

<ul>
<li>100% Brand new and high quality</li>
<li>Professional quality B500K Potentiometer, audio tone switch, for electric guitars</li>
<li>This is a brand new part and comes with washer and nut</li>
<li>Resistance: 500K ohm</li>
<li>Base Dia: 16mm</li>
<li>Shaft Length: 18mm</li>
<li>Split Shaft: 6mm</li>
<li>Weight: 42g</li>
</ul>

<p>Package includes:</p>

<ul>
<li>B500K Switch x 6</li>
</ul>

<h2>10 pcs 9V PP3 9Volt battery snap on clip connector T Type Holder Lead Wire</h2>

<p>(<a href="http://www.ebay.co.uk/itm/390845146632">http://www.ebay.co.uk/itm/390845146632</a>) - £1.00</p>

<p><img src="Compras_2.jpg" alt="Compras_2" /></p>

<p>Description</p>

<ul>
<li>Snap-on 9V battery clip connector</li>
<li>size : 12cm</li>
</ul>

<p>Package includes:</p>

<ul>
<li>10 pcs 9V clip connector T type</li>
</ul>

<h2>Ceramic Capacitor bag/25 kinds volumes/each 10/250pcs/Separate Loading Sales N</h2>

<p>(<a href="http://www.ebay.co.uk/itm/261491101172">http://www.ebay.co.uk/itm/261491101172</a>) - £1.20</p>

<p><img src="Compras_3.jpg" alt="Compras_3" /></p>

<hr />

<p>That's all Folks!</p>

					</div>
				</section>
				</div> <!-- Container -->

				<footer id="footer" class="panel-footer">
					<div class="inner">
						<a href="https://github.com/PhileCMS/Phile">Phile</a> was made by <a href="https://github.com/PhileCMS">The PhileCMS Community</a>.
					</div>
				</footer>
			</div>
		</div>
</div>
		<script data-cfasync="false" src="../../../../../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-20725619-1']);
            _gaq.push(['_trackPageview']);
            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
		<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.altlab.org/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
	</body>
</html>
