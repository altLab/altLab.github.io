<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

		<!-- <base href="https://altlab.org/d/" />  -->
		<title>Newsletter altLab - 2015-09-15 - Nº 20 | altLab Documenta</title>
				<meta name="description" content="Newsletters altLab Nº 20 de 15 de Setembro de 2015">
				<meta property="og:type" content="article" />
		<meta property="og:title" content="Newsletter altLab - 2015-09-15 - Nº 20 | altLab Documenta" />
		<meta property="og:description" content="Newsletters altLab Nº 20 de 15 de Setembro de 2015" />
		<meta property="og:url" content="https://altlab.org/d/m/jpralves/newsletters/2015/20/" />
		<meta property="og:site_name" content="altLab Documenta" />

		<!-- Bootstrap -->
		<link href="../../../../../themes/altlab/css/bootstrap.min.css" rel="stylesheet">
		<link href="../../../../../themes/altlab/override-test.css" rel="stylesheet">
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="../../../../../themes/altlab/js/jquery-1.12.4.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="../../../../../themes/altlab/js/bootstrap.min.js"></script>

	</head>
	<body>
<div class="container">
<div class="container-fluid">
      <div class="page-header hidden-xs" id="brand-logo">
        <h1><a href="../../../../../../index.html"><img src="../../../../../themes/altlab/altlab-logo-gradoverwhite.png" width="180" height="120" alt="Home" style="vertical-align:text-bottom" /></a> Documenta <span class="glyphicon glyphicon-leaf" style="color:#98ff98; padding-left:5px; top:2.8px;"></span></h1>

      </div>
			<nav class="navbar navbar-inverse">

				<div class="container-fluid">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#myNavbar">
							<span class="sr-only">Toggle navigation</span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
<div class="visible-xs">
<a class="navbar-brand" href="../../../../../../index.html"><img src="../../../../../themes/altlab/altlab-logo-documenta.png" width="58" height="35" alt="Home" style="margin-top: -7px;"></a>
						<a class="navbar-brand" href="../../../../../index.html">Documenta <span class="glyphicon glyphicon-leaf" style="color:#98ff98; padding-left:5px; top:2.8px;"></span></a></div>
					</div>
					<div class="collapse navbar-collapse" id="myNavbar">
						<ul class="nav navbar-nav">

           	<li id="dropdown.1" class="dropdown">
		<a class= "dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Membros <span class="caret"></span></a>
  
    <ul class="dropdown-menu">
<li>
<a href="../../../../index.html">Index</a>
</li>
   
           	<li id="dropdown.101" class="dropdown">
		<a href="../../../index.html">João Alves <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.102" class="dropdown">
		<a href="../../../../sislog/index.html">Fernando Carvalho <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.103" class="dropdown">
		<a href="../../../../pangelo/index.html">Pedro Ângelo <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.104" class="dropdown">
		<a href="../../../../dinix/index.html">Dinix <span class="caret"></span></a>
  
      	</li>
            	<li>
		<a href="../../../../funke/funke.html">m/funke/funke</a>
  
   	</li>
            	<li id="dropdown.106" class="dropdown">
		<a href="../../../../afonsom/index.html">Afonso Muralha <span class="caret"></span></a>
  
      	</li>
            	<li id="dropdown.107" class="dropdown">
		<a href="../../../../x3msnake/index.html">X3msnake <span class="caret"></span></a>
  
      	</li>
            	<li>
		<a href="../../../../ampmendes/index.html">António Mendes</a>
  
   	</li>
            	<li>
		<a href="../../../../guardajoao/index.html">GuardaJoao</a>
  
   	</li>
            	<li>
		<a href="../../../../jac/index.html">JAC</a>
  
   	</li>
            	<li>
		<a href="../../../../nini/index.html">Nuno Nini</a>
  
   	</li>
 
</ul>
    	</li>
            	<li id="dropdown.2" class="dropdown">
		<a class= "dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Documentação Partilhada <span class="caret"></span></a>
  
    <ul class="dropdown-menu">
<li>
<a href="../../../../../s/index.html">Index</a>
</li>
   
                         	<li id="dropdown.203" class="dropdown">
		<a href="../../../../../s/workshops/index.html">Workshops <span class="caret"></span></a>
  
      	</li>
                   	<li>
		<a href="../../../../../s/documenta/index.html">Documenta DevMap</a>
  
   	</li>
                   	<li>
		<a href="../../../../../s/processos/index.html">Processos do Lab (draft)</a>
  
   	</li>
            	<li id="dropdown.208" class="dropdown">
		<a href="../../../../../s/recursos/index.html">Recursos <span class="caret"></span></a>
  
      	</li>
 
</ul>
    	</li>
 
						</ul>
					</div>
				</div>
			</nav>

			<div class="container">
				<div class="container">
				<section id="content">
					<div class="inner">
						<h1 id="topo"><img src="../res/__Titulo.png" alt="Newsletter altLab" /></h1>

<p>2015-09-15 - Nº 20</p>

<div id="google_translate_element"></div>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'pt', layout: google.translate.TranslateElement.FloatPosition.TOP_LEFT, multilanguagePage: true}, 'google_translate_element');
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<h1>Editorial</h1>

<p>Aqui está a Newsletter Nº 20 no seu formato habitual.</p>

<p>Esta Newsletter encontra-se mais uma vez disponível no sistema documenta do altLab.
Todas as Newsletters encontram-se indexadas no <a href="../../index.html">link</a>.</p>

<p>Esta Newsletter tem os seguintes tópicos:</p>

<ul>
<li><a href="#Novidades-da-Semana">Novidades da Semana</a></li>
<li><a href="#Ciencia-e-Tecnologia">Ciência e Tecnologia</a></li>
<li><a href="#Cursos-MOOC">Cursos MOOC</a></li>
<li><a href="#Modelos-3D">Modelos 3D</a></li>
<li><a href="#Circuitos">Circuitos</a></li>
<li><a href="#Artigo-do-Maker">Artigo do Maker</a></li>
<li><a href="#Compras">Compras</a></li>
</ul>

<p>Um paciente espanhol vai recebeu um conjunto de costelas impressas em 3D para substituir as suas. A Xerox desenvolveu um Chip capaz de se auto destruir em 10 segundos. A Boeing desenvolveu o primeiro Satélite de propulsão totalmente eléctrica.
A Maker Faire Lisboa é já no próximo fim-de-semana e eu e o altLab lá estaremos.
Nesta Newsletter iremos apresentar um  projeto de maker que é um <em>spider robot</em> com 4 pernas. Iremos construir um circuito para um emissor de rádio FM.</p>

<p><img src="../res/_jpralves.jpg" alt="jpralves" /> João Alves (<a href="https://altlab.org/d/m/jpralves/newsletters/2015/20/&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x6a;&#112;&#114;&#x61;&#108;&#118;&#x65;&#x73;&#64;g&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;o&#x6d;#x6d;&a&i&l&t&o&:&j&p&r&a&l&v&e&s&@g&m&a&i&l&.&co&m"><span class="__cf_email__" data-cfemail="cda7bdbfaca1bba8be8daaa0aca4a1e3aea2a0">[email&#160;protected]</span></a>)</p>

<p>O conteúdo da Newsletter encontra-se sob a licença <img src="../res/_by-nc-sa4.0.png" alt="by-nc-sa4.0" /> <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>

<hr />

<h1 id="Novidades-da-Semana">Novidades da Semana <a href="#topo">^</a></h1>

<ul>
<li><p><a href="http://www.csiro.au/en/News/News-releases/2015/Cancer-patient-receives-3D-printed-ribs-in-world-first-surgery">Cancer patient receives 3D printed ribs in world first surgery</a></p>

<p><img src="NS20_CancerPatientReceives3DPrinted.jpg" alt="NS20_CancerPatientReceives3DPrinted" /></p>

<p><em>"Suffering from a chest wall sarcoma (a type of tumour that grows in and around the rib cage), the 54-year-old man needed his sternum and a portion of his rib cage replaced. This part of the chest is notoriously tricky to recreate with prosthetics, due to the complex geometry and intricate structures involved. So the patient’s surgical team from Salamanca University Hospital determined that a fully customisable 3D printed sternum and rib cage was the best option. That’s when they turned to Melbourne-based medical device company Anatomics, who designed and manufactured the implant utilising CSIRO’s 3D printing facility, Lab 22."</em></p></li>
<li><p><a href="http://www.computerworld.com.au/article/584274/xerox-parc-new-chip-will-self-destruct-10-seconds/">Xerox PARC's new chip will self destruct in 10 seconds</a></p>

<p><img src="NS20_XeroxParcSNewChipWillSelfDestr.jpg" alt="NS20_XeroxParcSNewChipWillSelfDestr" /></p>

<p><em>"Engineers at Xerox PARC have developed a chip that will self-destruct upon command, providing a potentially revolutionary tool for high-security applications. The chip, developed as part of DARPA’s vanishing programmable resources project, could be used to store data such as encryption keys and, on command, shatter into thousands of pieces so small, reconstruction is impossible."</em></p></li>
<li><p><a href="http://boeing.mediaroom.com/index.php?s=20295&amp;item=129516">Boeing: World’s First All-Electric Propulsion Satellite Begins Operations</a></p>

<p><img src="NS20_BoeingWorldsFirstAllElectricPr.jpg" alt="NS20_BoeingWorldsFirstAllElectricPr" /></p>

<p><em>"The world’s first all-electric propulsion satellite, built by Boeing [NYSE: BA] for Bermuda-based ABS, is now operational after an on-orbit handover on August 31. The ABS-3A, a 702SP (small platform) satellite, expands ABS’ communications services in the Americas, Europe, the Middle East and Africa. The ABS-3A spacecraft was the world’s first all-electric propulsion satellite to be built and launched – part of a stacked pair launched in March with a 702SP satellite built for Eutelsat, based in Paris. The spacecraft’s all-electric xenon-ion propulsion system contains a sufficient quantity of the inert, non-hazardous element xenon to extend the satellite’s operations beyond the expected spacecraft design life of 15 years."</em></p></li>
</ul>

<hr />

<h1 id="Ciencia-e-Tecnologia">Ciência e Tecnologia <a href="#topo">^</a></h1>

<ul>
<li><p><a href="http://pubs.acs.org/doi/abs/10.1021/acsmacrolett.5b00315">Rapid, Puncture-Initiated Healing via Oxygen-Mediated Polymerization</a></p>

<p><img src="CT20_RapidPunctureInitiatedHealingV.jpg" alt="CT20_RapidPunctureInitiatedHealingV" /></p>

<p><em>"Autonomously healing materials that utilize thiol–ene polymerization initiated by an environmentally borne reaction stimulus are demonstrated by puncturing trilayered panels, fabricated by sandwiching thiol–ene–trialkylborane resin formulations between solid polymer panels, with high velocity projectiles; as the reactive liquid layer flows into the entrance hole, contact with atmospheric oxygen initiates polymerization, converting the liquid into a solid plug. Using infrared spectroscopy, we find that formulated resins polymerize rapidly, forming a solid polymer within seconds of atmospheric contact. During high-velocity ballistics experiments, additional evidence for rapid polymerization is provided by high-speed video, demonstrating the immediate viscosity increase when the thiol–ene–trialkylborane resins contact atmospheric oxygen, and thermal imaging, where surface temperature measurements reveal the thiol–ene reaction exotherm, confirming polymerization begins immediately upon oxygen exposure. While other approaches for materials self-repair have utilized similar liquid-to-solid transitions, our approach permits the development of materials capable of sealing a breach within seconds, far faster than previously described methods."</em></p></li>
<li><p><a href="http://www.nature.com/articles/srep12488">A Magnetic Wormhole</a></p>

<p><img src="CT20_AMagneticWormhole.jpg" alt="CT20_AMagneticWormhole" /></p>

<p><em>"Wormholes are fascinating cosmological objects that can connect two distant regions of the universe. Because of their intriguing nature, constructing a wormhole in a lab seems a formidable task. A theoretical proposal by Greenleaf et al. presented a strategy to build a wormhole for electromagnetic waves. Based on metamaterials, it could allow electromagnetic wave propagation between two points in space through an invisible tunnel. However, an actual realization has not been possible until now. Here we construct and experimentally demonstrate a magnetostatic wormhole. Using magnetic metamaterials and metasurfaces, our wormhole transfers the magnetic field from one point in space to another through a path that is magnetically undetectable. We experimentally show that the magnetic field from a source at one end of the wormhole appears at the other end as an isolated magnetic monopolar field, creating the illusion of a magnetic field propagating through a tunnel outside the 3D space. Practical applications of the results can be envisaged, including medical techniques based on magnetism."</em></p></li>
<li><p><a href="http://www.sciencemag.org/content/345/6197/644">A method for building self-folding machines</a></p>

<p><img src="CT20_AMethodForBuildingSelfFoldingM.jpg" alt="CT20_AMethodForBuildingSelfFoldingM" /></p>

<p><em>"Origami can turn a sheet of paper into complex three-dimensional shapes, and similar folding techniques can produce structures and mechanisms. To demonstrate the application of these techniques to the fabrication of machines, we developed a crawling robot that folds itself. The robot starts as a flat sheet with embedded electronics, and transforms autonomously into a functional machine. To accomplish this, we developed shape-memory composites that fold themselves along embedded hinges. We used these composites to recreate fundamental folded patterns, derived from computational origami, that can be extrapolated to a wide range of geometries and mechanisms. This origami-inspired robot can fold itself in 4 minutes and walk away without human intervention, demonstrating the potential both for complex self-folding machines and autonomous, self-controlled assembly."</em></p></li>
</ul>

<hr />

<h1 id="Cursos-MOOC">Cursos MOOC <a href="#topo">^</a></h1>

<ul>
<li><a href="https://novoed.com/venture1-2015-2">Technology Entrepreneurship</a> - Começa a 16 de Setembro.</li>
<li><a href="https://www.futurelearn.com/courses/begin-robotics">Begin Robotics</a> - Começa a 21 de Setembro.</li>
<li><a href="https://www.coursera.org/course/crypto2">Cryptography II</a> - Começa a 19 de Outubro.</li>
</ul>

<hr />

<h1 id="Modelos-3D">Modelos 3D <a href="#topo">^</a></h1>

<p>Com a disponibilidade de ferramentas que permitem dar azo a nossa imaginação na criação de peças 3D e espaços como o <a href="http://www.thingiverse.com/">thingiverse</a> para as publicar, esta rubrica apresenta alguns modelos selecionados que poderão ser úteis.</p>

<h2>Push Drill with Adjustable Chuck (<a href="http://www.thingiverse.com/thing:792988">http://www.thingiverse.com/thing:792988</a>)</h2>

<p><img src="MP20_PushDrillWithAdjustableChuck.jpg" alt="MP20_PushDrillWithAdjustableChuck" /></p>

<p>Inspired by Speedy777's Pump Drill [link](http://www.thingiverse.com/thing:731086, which was inspired by Performance 3D's drill), this slightly beefier version features an adjustable chuck that can handle bits from 5mm (3/16") down to 1.5mm (1/16"). The end of the bit seats in the conical shaped chuck cavity, and the flexy fingers at the tip grab further up the shank. You get 2 full rotations per stroke for fast drilling. It also works as a pin vise for holding needle files.</p>

<h2>Small Parts Funnel Tray (<a href="http://www.thingiverse.com/thing:918864">http://www.thingiverse.com/thing:918864</a>)</h2>

<p><img src="MP20_SmallPartsFunnelTray.jpg" alt="Modelos3D_2_FunnelTray" /></p>

<p>I was shocked when I couldn't find one of these already on Thingiverse, so I made one.</p>

<h2>Parametric pulley - lots of tooth profiles (<a href="http://www.thingiverse.com/thing:16627">http://www.thingiverse.com/thing:16627</a>)</h2>

<p><img src="MP20_ParametricPulleyLotsOfToothPro.jpg" alt="Modelos3D_3_ParametricPulley" /></p>

<p>This thing will create a range of metric and imperial tooth profile pulleys, with any number of teeth, specified in the Openscad file. Tooth profiles currently supported are MXL, 40DP, XL, L, T2.5, T5, T10, AT5, HTD (3mm, 5mm, 8mm) and GT2 (2mm, 3mm 5mm). NOTE: error in script regarding L and H pulleys spotted by OSTycoon (see comments) - the script says H, but actually it is L profile. There are a range of editable parameters for editing the fit of the tooth (to account for printer variation), the pulley base, captive nut(s) slot for the set screw, motor shaft diameter, pulley height and belt retainers. The attached stls are reference pulleys, mostly around the size used on repraps.</p>

<p>Details After creating the parametric pulley http://www.thingiverse.com/thing:11256 I realised this way of modelling them was only going to work for square-toothed pulleys, and a way of producing pulleys for belts with better characteristics for linear motion was required. I found dxf drawings of the relevant tooth profiles here http://oem.cadregister.com/asp/PPOW_Entry.asp?company=915217&amp;elementID=07807803/METRIC/URETH/WV0025/F and modelled pulley diameter from data here http://www.sdp-si.com/D265/HTML/D265T016.html There were a couple of possible approaches to importing the data, I chose to simplify the bezier curve dxf data in Inkscape, producing vertices with a resolution of around 0.05-0.1mm for each tooth. Another advantage is the the pulleys have the tooth ramp for smooth entry and exit of the belt tooth into the pulley. I'm not really sure 3D printers can take full advantage of this yet, but quality is improving all the time! If other tooth profiles are required, or you model any, please pass them on to me and I will include them.</p>

<hr />

<h1 id="Circuitos">Circuitos <a href="#topo">^</a></h1>

<p>Aqui é apresentado um circuito simples que poderá ser construído com componentes.</p>

<h2>Emissor de FM simples</h2>

<p><img src="Circuitos20_1_EmissorFMsimples.jpg" alt="Circuitos_1" /></p>

<p>Hoje será construído um circuito para criar um emissor de FM muito simples. Este circuito como outros encontra-se bastante divulgado na Internet e apresenta uma configuração muito simples uma vez que apenas usa um Transístor NPN.
De notar que este circuito foi montado logo numa <em>veroboard</em> pois não funcionará muito bem em <em>Breadboard</em>.</p>

<p>O Circuito usa o que se chama o "Factor Q" da rede que é conseguida pela bobine e pelo condensador para produzir uma voltagem alta.
Para que o resultado seja mais efectivo deverá garantir-se que a bobine se encontra o mais próximo possível do condensador.</p>

<p>Para se construir a bobine deverá usar o parafuso M6 para enrolar 8 espiras à volta dele para formar a bobine.</p>

<p>Para regular a frequência de emissão deverá ser rodada o condensador variável com uma chave que não seja metálica (para não afectar a emissão).</p>

<p>Pode ser usado outro transístor NPN.</p>

<h2>Esquemático</h2>

<p><img src="Circuitos20_3_Schematics.png" alt="Circuitos_3_Schematics" /></p>

<h2>Componentes (BOM):</h2>

<p>Circuito:</p>

<ul>
<li>1x NPN <a href="https://en.wikipedia.org/wiki/2N3904">2N3904</a></li>
<li>1x Condensador Variável entre 10 e 40nF (C1)</li>
<li>1x Condensador de 5pF (C2)</li>
<li>1x Condensador de 22pF (C3)</li>
<li>1x Condensador 1nF (C4)</li>
<li>1x Resistência de 4.7K Ohms (R1)</li>
<li>1x Resistência de 330 Ohms (R2)</li>
<li>1x Indutor (L1)</li>
<li>1x MIC</li>
<li>1x Bateria de 9V</li>
</ul>

<h2>Pin-out dos IC/Componentes</h2>

<p><img src="Circuitos20_4_Pinout.png" alt="Circuitos_4_Pinout" /></p>

<h3>Links úteis:</h3>

<ul>
<li><a href="http://www.homemade-circuits.com/2014/08/spy-bug-circuits.html">Spy Circuits - FM Bug Transmitters</a></li>
<li><a href="http://makingcircuits.com/blog/2015/07/spy-circuits-fm-bug-transmitters.html">How to Build a Spy Circuits – FM Bug Transmitters</a></li>
<li><a href="http://www.lucidscience.com/pro-basic%20spy%20transmitter-1.aspx">Build the 2 transistor Spy Transmitter</a></li>
</ul>

<hr />

<h1 id="Artigo-do-Maker">Artigo do Maker <a href="#topo">^</a></h1>

<p>Projeto interessante publicado por um maker.</p>

<h2>Spider Robot</h2>

<p>O projecto de maker da semana foi feito pelo Regis Hsu e encontra-se publicado no seguinte <a href="http://www.instructables.com/id/DIY-Spider-RobotQuad-robot-Quadruped/?ALLSTEPS">link</a>.</p>

<p><img src="PM20_SpiderRobot.jpg" alt="ArtigoMaker1_DIY_SpiderRobot" /></p>

<p>É um robot tipo aranha. Que usa quarto patas para se deslocar.
Foi desenvolvido ao longo de um ano e encontra-se documentado no <a href="http://regishsu.blogspot.tw/p/blog-page_20.html">blog do autor</a>.</p>

<h3>Passo 1: Preparação das peças electricas</h3>

<p><img src="ArtigoMaker2_Passo1.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_1.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_2.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_3.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_4.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_5.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_6.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_7.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_8.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_9.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_10.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_11.jpg" alt="ArtigoMaker2_Passo1" />
<img src="ArtigoMaker2_Passo1_12.jpg" alt="ArtigoMaker2_Passo1" /></p>

<p>Aqui estão as partes necessárias:</p>

<ul>
<li>1x Arduino Pro Mini</li>
<li>1x DC-DC(12-5v/3A output)</li>
<li>1x módulo Bluetooth HC-06 (opção)</li>
<li>12x SG90 servo(3DOF para as 4 pernas)</li>
<li>1x bateria de 3000mhA Li</li>
<li>1x 12V Jack</li>
<li>1x Resistência de 680 Ohm 1/4 watt 5%</li>
<li>1x LED 3mm Azul</li>
<li>1x Botão táctil</li>
<li>1x perfboard de 5x7cm</li>
<li>Alguns headers macho e fêmea.</li>
<li>Fio (uni ou multifilar)</li>
</ul>

<h3>Passo 2: Construir a placa principal</h3>

<p><img src="ArtigoMaker3_Passo2.jpg" alt="ArtigoMaker3_Passo2" />
<img src="ArtigoMaker3_Passo2_1.jpg" alt="ArtigoMaker3_Passo2" />
<img src="ArtigoMaker3_Passo2_2.jpg" alt="ArtigoMaker3_Passo2" /></p>

<p>Ver no ficheiro do <a href="ArtigoMaker3_Schematics.pdf">esquemático</a> para se perceber melhor as conexões e colocar os componentes de acordo com as imagens.</p>

<p>Algumas dicas:</p>

<ul>
<li>Ter a certeza que a saída do modulo DC-DC é 5V</li>
<li>Os servos gastam bastante energia (perto de 3A) em condições de utilização total.</li>
<li>Verificar com o multímetro se as ligações estão corretamente feitas.</li>
<li>Use um <em>header</em> fêmea em vez de soldar os módulos diretamente na <em>perfboard</em>.</li>
<li>O LED ficará ligado quando o botão estiver desligado. Foi assim desenhado para que se possa ter a certeza que o robot está alimentado.</li>
</ul>

<h3>Passo 3: testar a placa principal</h3>

<p><img src="ArtigoMaker4_Passo3.jpg" alt="ArtigoMaker4_Passo3" /></p>

<p>Processo de teste:</p>

<ul>
<li>Não ligar o DC-DC e o Arduino Pro Mini na placa principal</li>
<li>Ligar a bateria ao Jack de 12V da placa principal</li>
<li>Verificar o LED, se acender, é um bom começo</li>
<li>Carregar no botão de ligar, o LED deverá ficar apagado</li>
<li>Usando um multímetro verifique que todos os pontos de +5V e de GND estão corretos.</li>
<li>Carregue no botão de ligar novamente, o LED deverá acender.</li>
<li>Ligue o modulo DC-DC e o Arduino Pro Mini à placa principal</li>
<li>Carregue no botão de ligar, o LED apagará, mas o LED do Arduino Mini ficará ligado</li>
</ul>

<p>Depois desligue o robot, e  ligue um servo na primeira perna do robot com a indicação de Leg1 (pino 2 do Arduino)
Carregue no código "servo_test" no Arduino para verificar o funcionamento do servo (deverá movimentar-se entre os 0 e os 180 graus).</p>

<p>O <a href="servo_test.ino">código</a> "servo_test":</p>

<pre><code>/* Sweep
 by BARRAGAN &lt;http://barraganstudio.com&gt;
 This example code is in the public domain.

 modified 8 Nov 2013
 by Scott Fitzgerald
 http://www.arduino.cc/en/Tutorial/Sweep
*/

#include &lt;Servo.h&gt;

Servo myservo;  // create servo object to control a servo
// twelve servo objects can be created on most boards

int pos = 0;    // variable to store the servo position

void setup() {
  myservo.attach(2);  // attaches the servo on pin 2 to the servo object
}

void loop() {
  for (pos = 0; pos &lt;= 180; pos += 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    myservo.write(pos);              // tell servo to go to position in variable 'pos'
    delay(15);                       // waits 15ms for the servo to reach the position
  }
  for (pos = 180; pos &gt;= 0; pos -= 1) { // goes from 180 degrees to 0 degrees
    myservo.write(pos);              // tell servo to go to position in variable 'pos'
    delay(15);                       // waits 15ms for the servo to reach the position
  }
}
</code></pre>

<h3>Passo 4: Construir as partes mecânicas: Descarregar os ficheiros STL</h3>

<p><img src="ArtigoMaker5_Passo4.jpg" alt="ArtigoMaker5_Passo4" /></p>

<p>Neste passo iremos imprimir em 3D as partes mecânicas do robot.
Descarregue as partes do link do <a href="http://www.thingiverse.com/thing:1009659">thingiverse</a> ou <a href="ArtigoMaker5_Passo4_STL.zip">localmente</a>.</p>

<p>Lista de partes a imprimir:</p>

<ul>
<li>1x body_d.stl</li>
<li>1x body_u.stl</li>
<li>2x coxa_l.stl</li>
<li>2x coxa_r.stl</li>
<li>2x tibia_l.stl</li>
<li>2x tibia_r.stl</li>
<li>4x femur_1.stl</li>
<li>8x s_hold.stl</li>
</ul>

<h3>Passo 5: Imprimir os objectos 3D</h3>

<p><img src="ArtigoMaker6_Passo5.jpg" alt="ArtigoMaker6_Passo5" /></p>

<p>A impressão de todas as peças deve demorar cerca de 7 a 8 horas por isso verifique bem se as configurações da impressora estão correctas.
É sugerida que seja usado uma densidade de enchimento de cerca de 35% para criar a estrutura das pernas mais forte.</p>

<p>Podem ser impressas as peças por grupo de cores.</p>

<h3>Passo 6: Preparação para a montagem</h3>

<p><img src="ArtigoMaker7_Passo6.jpg" alt="ArtigoMaker7_Passo6" /></p>

<p>Verifique a qualidade das peças impressas. Pode ser usada lixa para polir um pouco as superficies e retirar as imperfeições.</p>

<h3>Passo 7: Montagem do corpo</h3>

<p><img src="ArtigoMaker8_Passo7.jpg" alt="ArtigoMaker8_Passo7" />
<img src="ArtigoMaker8_Passo7_1.jpg" alt="ArtigoMaker8_Passo7_1" /></p>

<p>Coloque a bateria entre a parte superior da caixa e a parte inferior juntando-as com 4 parafusos M3x25mm.</p>

<h3>Passo 8: Montagem da perna</h3>

<p><img src="ArtigoMaker9_Passo8.jpg" alt="ArtigoMaker9_Passo8" />
<img src="ArtigoMaker9_Passo8_1.jpg" alt="ArtigoMaker9_Passo8_1" /></p>

<p>E instalar todos os servos com as partes das pernas, cada perna tem 3 servos e 4 parafusos (M1.6x3mm)</p>

<p>Notas:</p>

<ol>
<li>Ligar todas as partes com parafusos e os servos mas nao ligar o braço "rocker" neste passo.</li>
<li>Verifique a direção da perna - verifique a imagem</li>
</ol>

<h3>Passo 9: Integração das pernas no corpo</h3>

<p><img src="ArtigoMaker10_Passo9.jpg" alt="ArtigoMaker10_Passo9" /></p>

<p>Ligar as pernas todas no corpo, verificar se todos os servos e juntas se movem bem.</p>

<h3>Passo 10: Ligar os servos à placa principal</h3>

<p><img src="ArtigoMaker11_Passo10.jpg" alt="ArtigoMaker11_Passo10" />
<img src="ArtigoMaker11_Passo10_1.jpg" alt="ArtigoMaker11_Passo10_1" /></p>

<p>Coloque a placa principal na caixa do corpo e fixe-a com cerâmica plástica.</p>

<p>Ligue os pinos de acordo com o indicado na imagem (cor rosa). A cor verde apresenta a direção do sinal do fio do servo, amarelo liga ao "S", vermelho ao "+" e castanho ao "-".</p>

<p>Tenha a certeza que os servos das pernas estão ligados aos pinos certos e nas direções certas das pernas, de outra forma o robot ficará "louco"!</p>

<h3>Passo 11: Localizar a posição inicial das pernas</h3>

<p><img src="ArtigoMaker12_Passo11.jpg" alt="ArtigoMaker12_Passo11" /></p>

<p>Procedimento de instalação:</p>

<ol>
<li>carregar o código "legs_init" para o Arduino para activar os servos</li>
<li>Colocar as pernas na posição apresentada na imagem acima, instalar o servo rocker com parafusos.</li>
<li>Apertar bem todos os parafusos</li>
</ol>

<p>O <a href="legs_init.ino">código</a> "legs_init" :</p>

<pre><code>// Locate the initial position of legs
// RegisHsu 2015-09-09

#include &lt;Servo.h&gt;

Servo servo[4][3];

//define servos' ports
const int servo_pin[4][3] = { {2, 3, 4}, {5, 6, 7}, {8, 9, 10}, {11, 12, 13} };

void setup()
{
  //initialize all servos
  for (int i = 0; i &lt; 4; i++)
  {
    for (int j = 0; j &lt; 3; j++)
    {
      servo[i][j].attach(servo_pin[i][j]);
      delay(100);
    }
  }
  while (1);
}

void loop(void)
{
}
</code></pre>

<h3>Passo 12: Organização dos Fios</h3>

<p><img src="ArtigoMaker13_Passo12.jpg" alt="ArtigoMaker13_Passo12" /></p>

<p>Agora, falta organizar os fios para que o robot tenha bom aspecto.</p>

<p>Finalmente toda a instalação do hardware está completa.</p>

<h3>Passo 13: Hora de ver o robot a mexer!</h3>

<p>Veja o <a href="https://youtu.be/5hAmD499sJs">Video</a> do robot em acção.</p>

<p>Carregar o <a href="spider_open_v1.ino">código</a> "spider_open_v1" no Arduino para o fazer mover.</p>

<p>A sequência de acções programadas são:</p>

<ol>
<li>Por-se em pé, espera 2 segundos</li>
<li>Avança para a frente 5 passos, espera 2 segundos</li>
<li>Recua para trás 5 passos, espera 2 segundos</li>
<li>Vira à direita, espera 2 segundos</li>
<li>Vira à esquerda, espera 2 segundos</li>
<li>Move a mão, espera 2 segundos</li>
<li>Abana a mão, espera 2 segundos</li>
<li>Senta-se, espera 2 segundos</li>
<li>Volta ao passo 1</li>
</ol>

<pre><code>/* -----------------------------------------------------------------------------
  - Project: Remote control Crawling robot
  - Author:  <a href="../../../../../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="aadacbc4cfd8dbc3cbc4cdead9dfc4ccc5dfc4cecfd884c9c5c7">[email&#160;protected]</a>
  - Date:  2015/1/27
   -----------------------------------------------------------------------------
  - Overview
  - This project was written for the Crawling robot desigened by Sunfounder.
    This version of the robot has 4 legs, and each leg is driven by 3 servos.
  This robot is driven by a Ardunio Nano Board with an expansion Board.
  We recommend that you view the product documentation before using.
  - Request
  - This project requires some library files, which you can find in the head of
    this file. Make sure you have installed these files.
  - How to
  - Before use,you must to adjust the robot,in order to make it more accurate.
    - Adjustment operation
    1.uncomment ADJUST, make and run
    2.comment ADJUST, uncomment VERIFY
    3.measure real sites and set to real_site[4][3], make and run
    4.comment VERIFY, make and run
  The document describes in detail how to operate.
   ---------------------------------------------------------------------------*/

// modified by Regis for spider project

/* Includes ------------------------------------------------------------------*/
#include &lt;Servo.h&gt;    //to define and control servos
#include &lt;FlexiTimer2.h&gt;//to set a timer to manage all servos
/* Servos --------------------------------------------------------------------*/
//define 12 servos for 4 legs
Servo servo[4][3];
//define servos' ports
const int servo_pin[4][3] = { {2, 3, 4}, {5, 6, 7}, {8, 9, 10}, {11, 12, 13} };
/* Size of the robot ---------------------------------------------------------*/
const float length_a = 55;
const float length_b = 77.5;
const float length_c = 27.5;
const float length_side = 71;
const float z_absolute = -28;
/* Constants for movement ----------------------------------------------------*/
const float z_default = -50, z_up = -30, z_boot = z_absolute;
const float x_default = 62, x_offset = 0;
const float y_start = 0, y_step = 40;
/* variables for movement ----------------------------------------------------*/
volatile float site_now[4][3];    //real-time coordinates of the end of each leg
volatile float site_expect[4][3]; //expected coordinates of the end of each leg
float temp_speed[4][3];   //each axis' speed, needs to be recalculated before each movement
float move_speed;     //movement speed
float speed_multiple = 1; //movement speed multiple
const float spot_turn_speed = 4;
const float leg_move_speed = 8;
const float body_move_speed = 3;
const float stand_seat_speed = 1;
volatile int rest_counter;      //+1/0.02s, for automatic rest
//functions' parameter
const float KEEP = 255;
//define PI for calculation
const float pi = 3.1415926;
/* Constants for turn --------------------------------------------------------*/
//temp length
const float temp_a = sqrt(pow(2 * x_default + length_side, 2) + pow(y_step, 2));
const float temp_b = 2 * (y_start + y_step) + length_side;
const float temp_c = sqrt(pow(2 * x_default + length_side, 2) + pow(2 * y_start + y_step + length_side, 2));
const float temp_alpha = acos((pow(temp_a, 2) + pow(temp_b, 2) - pow(temp_c, 2)) / 2 / temp_a / temp_b);
//site for turn
const float turn_x1 = (temp_a - length_side) / 2;
const float turn_y1 = y_start + y_step / 2;
const float turn_x0 = turn_x1 - temp_b * cos(temp_alpha);
const float turn_y0 = temp_b * sin(temp_alpha) - turn_y1 - length_side;
/* ---------------------------------------------------------------------------*/

/*
  - setup function
   ---------------------------------------------------------------------------*/
void setup()
{
  //start serial for debug
  Serial.begin(115200);
  Serial.println("Robot starts initialization");
  //initialize default parameter
  set_site(0, x_default - x_offset, y_start + y_step, z_boot);
  set_site(1, x_default - x_offset, y_start + y_step, z_boot);
  set_site(2, x_default + x_offset, y_start, z_boot);
  set_site(3, x_default + x_offset, y_start, z_boot);
  for (int i = 0; i &lt; 4; i++)
  {
    for (int j = 0; j &lt; 3; j++)
    {
      site_now[i][j] = site_expect[i][j];
    }
  }
  //start servo service
  FlexiTimer2::set(20, servo_service);
  FlexiTimer2::start();
  Serial.println("Servo service started");
  //initialize servos
  servo_attach();
  Serial.println("Servos initialized");
  Serial.println("Robot initialization Complete");
}


void servo_attach(void)
{
  for (int i = 0; i &lt; 4; i++)
  {
    for (int j = 0; j &lt; 3; j++)
    {
      servo[i][j].attach(servo_pin[i][j]);
      delay(100);
    }
  }
}

void servo_detach(void)
{
  for (int i = 0; i &lt; 4; i++)
  {
    for (int j = 0; j &lt; 3; j++)
    {
      servo[i][j].detach();
      delay(100);
    }
  }
}
/*
  - loop function
   ---------------------------------------------------------------------------*/
void loop()
{
  Serial.println("Stand");
  stand();
  delay(2000);
  Serial.println("Step forward");
  step_forward(5);
  delay(2000);
  Serial.println("Step back");
  step_back(5);
  delay(2000);
  Serial.println("Turn left");
  turn_left(5);
  delay(2000);
  Serial.println("Turn right");
  turn_right(5);
  delay(2000);
  Serial.println("Hand wave");
  hand_wave(3);
  delay(2000);
  Serial.println("Hand wave");
  hand_shake(3);
  delay(2000);
  Serial.println("Sit");
  sit();
  delay(5000);
}

/*
  - sit
  - blocking function
   ---------------------------------------------------------------------------*/
void sit(void)
{
  move_speed = stand_seat_speed;
  for (int leg = 0; leg &lt; 4; leg++)
  {
    set_site(leg, KEEP, KEEP, z_boot);
  }
  wait_all_reach();
}

/*
  - stand
  - blocking function
   ---------------------------------------------------------------------------*/
void stand(void)
{
  move_speed = stand_seat_speed;
  for (int leg = 0; leg &lt; 4; leg++)
  {
    set_site(leg, KEEP, KEEP, z_default);
  }
  wait_all_reach();
}


/*
  - spot turn to left
  - blocking function
  - parameter step steps wanted to turn
   ---------------------------------------------------------------------------*/
void turn_left(unsigned int step)
{
  move_speed = spot_turn_speed;
  while (step-- &gt; 0)
  {
    if (site_now[3][1] == y_start)
    {
      //leg 3&amp;1 move
      set_site(3, x_default + x_offset, y_start, z_up);
      wait_all_reach();

      set_site(0, turn_x1 - x_offset, turn_y1, z_default);
      set_site(1, turn_x0 - x_offset, turn_y0, z_default);
      set_site(2, turn_x1 + x_offset, turn_y1, z_default);
      set_site(3, turn_x0 + x_offset, turn_y0, z_up);
      wait_all_reach();

      set_site(3, turn_x0 + x_offset, turn_y0, z_default);
      wait_all_reach();

      set_site(0, turn_x1 + x_offset, turn_y1, z_default);
      set_site(1, turn_x0 + x_offset, turn_y0, z_default);
      set_site(2, turn_x1 - x_offset, turn_y1, z_default);
      set_site(3, turn_x0 - x_offset, turn_y0, z_default);
      wait_all_reach();

      set_site(1, turn_x0 + x_offset, turn_y0, z_up);
      wait_all_reach();

      set_site(0, x_default + x_offset, y_start, z_default);
      set_site(1, x_default + x_offset, y_start, z_up);
      set_site(2, x_default - x_offset, y_start + y_step, z_default);
      set_site(3, x_default - x_offset, y_start + y_step, z_default);
      wait_all_reach();

      set_site(1, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
    else
    {
      //leg 0&amp;2 move
      set_site(0, x_default + x_offset, y_start, z_up);
      wait_all_reach();

      set_site(0, turn_x0 + x_offset, turn_y0, z_up);
      set_site(1, turn_x1 + x_offset, turn_y1, z_default);
      set_site(2, turn_x0 - x_offset, turn_y0, z_default);
      set_site(3, turn_x1 - x_offset, turn_y1, z_default);
      wait_all_reach();

      set_site(0, turn_x0 + x_offset, turn_y0, z_default);
      wait_all_reach();

      set_site(0, turn_x0 - x_offset, turn_y0, z_default);
      set_site(1, turn_x1 - x_offset, turn_y1, z_default);
      set_site(2, turn_x0 + x_offset, turn_y0, z_default);
      set_site(3, turn_x1 + x_offset, turn_y1, z_default);
      wait_all_reach();

      set_site(2, turn_x0 + x_offset, turn_y0, z_up);
      wait_all_reach();

      set_site(0, x_default - x_offset, y_start + y_step, z_default);
      set_site(1, x_default - x_offset, y_start + y_step, z_default);
      set_site(2, x_default + x_offset, y_start, z_up);
      set_site(3, x_default + x_offset, y_start, z_default);
      wait_all_reach();

      set_site(2, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
  }
}

/*
  - spot turn to right
  - blocking function
  - parameter step steps wanted to turn
   ---------------------------------------------------------------------------*/
void turn_right(unsigned int step)
{
  move_speed = spot_turn_speed;
  while (step-- &gt; 0)
  {
    if (site_now[2][1] == y_start)
    {
      //leg 2&amp;0 move
      set_site(2, x_default + x_offset, y_start, z_up);
      wait_all_reach();

      set_site(0, turn_x0 - x_offset, turn_y0, z_default);
      set_site(1, turn_x1 - x_offset, turn_y1, z_default);
      set_site(2, turn_x0 + x_offset, turn_y0, z_up);
      set_site(3, turn_x1 + x_offset, turn_y1, z_default);
      wait_all_reach();

      set_site(2, turn_x0 + x_offset, turn_y0, z_default);
      wait_all_reach();

      set_site(0, turn_x0 + x_offset, turn_y0, z_default);
      set_site(1, turn_x1 + x_offset, turn_y1, z_default);
      set_site(2, turn_x0 - x_offset, turn_y0, z_default);
      set_site(3, turn_x1 - x_offset, turn_y1, z_default);
      wait_all_reach();

      set_site(0, turn_x0 + x_offset, turn_y0, z_up);
      wait_all_reach();

      set_site(0, x_default + x_offset, y_start, z_up);
      set_site(1, x_default + x_offset, y_start, z_default);
      set_site(2, x_default - x_offset, y_start + y_step, z_default);
      set_site(3, x_default - x_offset, y_start + y_step, z_default);
      wait_all_reach();

      set_site(0, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
    else
    {
      //leg 1&amp;3 move
      set_site(1, x_default + x_offset, y_start, z_up);
      wait_all_reach();

      set_site(0, turn_x1 + x_offset, turn_y1, z_default);
      set_site(1, turn_x0 + x_offset, turn_y0, z_up);
      set_site(2, turn_x1 - x_offset, turn_y1, z_default);
      set_site(3, turn_x0 - x_offset, turn_y0, z_default);
      wait_all_reach();

      set_site(1, turn_x0 + x_offset, turn_y0, z_default);
      wait_all_reach();

      set_site(0, turn_x1 - x_offset, turn_y1, z_default);
      set_site(1, turn_x0 - x_offset, turn_y0, z_default);
      set_site(2, turn_x1 + x_offset, turn_y1, z_default);
      set_site(3, turn_x0 + x_offset, turn_y0, z_default);
      wait_all_reach();

      set_site(3, turn_x0 + x_offset, turn_y0, z_up);
      wait_all_reach();

      set_site(0, x_default - x_offset, y_start + y_step, z_default);
      set_site(1, x_default - x_offset, y_start + y_step, z_default);
      set_site(2, x_default + x_offset, y_start, z_default);
      set_site(3, x_default + x_offset, y_start, z_up);
      wait_all_reach();

      set_site(3, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
  }
}

/*
  - go forward
  - blocking function
  - parameter step steps wanted to go
   ---------------------------------------------------------------------------*/
void step_forward(unsigned int step)
{
  move_speed = leg_move_speed;
  while (step-- &gt; 0)
  {
    if (site_now[2][1] == y_start)
    {
      //leg 2&amp;1 move
      set_site(2, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(2, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(2, x_default + x_offset, y_start + 2 * y_step, z_default);
      wait_all_reach();

      move_speed = body_move_speed;

      set_site(0, x_default + x_offset, y_start, z_default);
      set_site(1, x_default + x_offset, y_start + 2 * y_step, z_default);
      set_site(2, x_default - x_offset, y_start + y_step, z_default);
      set_site(3, x_default - x_offset, y_start + y_step, z_default);
      wait_all_reach();

      move_speed = leg_move_speed;

      set_site(1, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(1, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(1, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
    else
    {
      //leg 0&amp;3 move
      set_site(0, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(0, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(0, x_default + x_offset, y_start + 2 * y_step, z_default);
      wait_all_reach();

      move_speed = body_move_speed;

      set_site(0, x_default - x_offset, y_start + y_step, z_default);
      set_site(1, x_default - x_offset, y_start + y_step, z_default);
      set_site(2, x_default + x_offset, y_start, z_default);
      set_site(3, x_default + x_offset, y_start + 2 * y_step, z_default);
      wait_all_reach();

      move_speed = leg_move_speed;

      set_site(3, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(3, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(3, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
  }
}

/*
  - go back
  - blocking function
  - parameter step steps wanted to go
   ---------------------------------------------------------------------------*/
void step_back(unsigned int step)
{
  move_speed = leg_move_speed;
  while (step-- &gt; 0)
  {
    if (site_now[3][1] == y_start)
    {
      //leg 3&amp;0 move
      set_site(3, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(3, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(3, x_default + x_offset, y_start + 2 * y_step, z_default);
      wait_all_reach();

      move_speed = body_move_speed;

      set_site(0, x_default + x_offset, y_start + 2 * y_step, z_default);
      set_site(1, x_default + x_offset, y_start, z_default);
      set_site(2, x_default - x_offset, y_start + y_step, z_default);
      set_site(3, x_default - x_offset, y_start + y_step, z_default);
      wait_all_reach();

      move_speed = leg_move_speed;

      set_site(0, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(0, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(0, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
    else
    {
      //leg 1&amp;2 move
      set_site(1, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(1, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(1, x_default + x_offset, y_start + 2 * y_step, z_default);
      wait_all_reach();

      move_speed = body_move_speed;

      set_site(0, x_default - x_offset, y_start + y_step, z_default);
      set_site(1, x_default - x_offset, y_start + y_step, z_default);
      set_site(2, x_default + x_offset, y_start + 2 * y_step, z_default);
      set_site(3, x_default + x_offset, y_start, z_default);
      wait_all_reach();

      move_speed = leg_move_speed;

      set_site(2, x_default + x_offset, y_start + 2 * y_step, z_up);
      wait_all_reach();
      set_site(2, x_default + x_offset, y_start, z_up);
      wait_all_reach();
      set_site(2, x_default + x_offset, y_start, z_default);
      wait_all_reach();
    }
  }
}

// add by RegisHsu

void body_left(int i)
{
  set_site(0, site_now[0][0] + i, KEEP, KEEP);
  set_site(1, site_now[1][0] + i, KEEP, KEEP);
  set_site(2, site_now[2][0] - i, KEEP, KEEP);
  set_site(3, site_now[3][0] - i, KEEP, KEEP);
  wait_all_reach();
}

void body_right(int i)
{
  set_site(0, site_now[0][0] - i, KEEP, KEEP);
  set_site(1, site_now[1][0] - i, KEEP, KEEP);
  set_site(2, site_now[2][0] + i, KEEP, KEEP);
  set_site(3, site_now[3][0] + i, KEEP, KEEP);
  wait_all_reach();
}

void hand_wave(int i)
{
  float x_tmp;
  float y_tmp;
  float z_tmp;
  move_speed = 1;
  if (site_now[3][1] == y_start)
  {
    body_right(15);
    x_tmp = site_now[2][0];
    y_tmp = site_now[2][1];
    z_tmp = site_now[2][2];
    move_speed = body_move_speed;
    for (int j = 0; j &lt; i; j++)
    {
      set_site(2, turn_x1, turn_y1, 50);
      wait_all_reach();
      set_site(2, turn_x0, turn_y0, 50);
      wait_all_reach();
    }
    set_site(2, x_tmp, y_tmp, z_tmp);
    wait_all_reach();
    move_speed = 1;
    body_left(15);
  }
  else
  {
    body_left(15);
    x_tmp = site_now[0][0];
    y_tmp = site_now[0][1];
    z_tmp = site_now[0][2];
    move_speed = body_move_speed;
    for (int j = 0; j &lt; i; j++)
    {
      set_site(0, turn_x1, turn_y1, 50);
      wait_all_reach();
      set_site(0, turn_x0, turn_y0, 50);
      wait_all_reach();
    }
    set_site(0, x_tmp, y_tmp, z_tmp);
    wait_all_reach();
    move_speed = 1;
    body_right(15);
  }
}

void hand_shake(int i)
{
  float x_tmp;
  float y_tmp;
  float z_tmp;
  move_speed = 1;
  if (site_now[3][1] == y_start)
  {
    body_right(15);
    x_tmp = site_now[2][0];
    y_tmp = site_now[2][1];
    z_tmp = site_now[2][2];
    move_speed = body_move_speed;
    for (int j = 0; j &lt; i; j++)
    {
      set_site(2, x_default - 30, y_start + 2 * y_step, 55);
      wait_all_reach();
      set_site(2, x_default - 30, y_start + 2 * y_step, 10);
      wait_all_reach();
    }
    set_site(2, x_tmp, y_tmp, z_tmp);
    wait_all_reach();
    move_speed = 1;
    body_left(15);
  }
  else
  {
    body_left(15);
    x_tmp = site_now[0][0];
    y_tmp = site_now[0][1];
    z_tmp = site_now[0][2];
    move_speed = body_move_speed;
    for (int j = 0; j &lt; i; j++)
    {
      set_site(0, x_default - 30, y_start + 2 * y_step, 55);
      wait_all_reach();
      set_site(0, x_default - 30, y_start + 2 * y_step, 10);
      wait_all_reach();
    }
    set_site(0, x_tmp, y_tmp, z_tmp);
    wait_all_reach();
    move_speed = 1;
    body_right(15);
  }
}



/*
  - microservos service /timer interrupt function/50Hz
  - when set site expected,this function move the end point to it in a straight line
  - temp_speed[4][3] should be set before set expect site,it make sure the end point
   move in a straight line,and decide move speed.
   ---------------------------------------------------------------------------*/
void servo_service(void)
{
  sei();
  static float alpha, beta, gamma;

  for (int i = 0; i &lt; 4; i++)
  {
    for (int j = 0; j &lt; 3; j++)
    {
      if (abs(site_now[i][j] - site_expect[i][j]) &gt;= abs(temp_speed[i][j]))
        site_now[i][j] += temp_speed[i][j];
      else
        site_now[i][j] = site_expect[i][j];
    }

    cartesian_to_polar(alpha, beta, gamma, site_now[i][0], site_now[i][1], site_now[i][2]);
    polar_to_servo(i, alpha, beta, gamma);
  }

  rest_counter++;
}

/*
  - set one of end points' expect site
  - this founction will set temp_speed[4][3] at same time
  - non - blocking function
   ---------------------------------------------------------------------------*/
void set_site(int leg, float x, float y, float z)
{
  float length_x = 0, length_y = 0, length_z = 0;

  if (x != KEEP)
    length_x = x - site_now[leg][0];
  if (y != KEEP)
    length_y = y - site_now[leg][1];
  if (z != KEEP)
    length_z = z - site_now[leg][2];

  float length = sqrt(pow(length_x, 2) + pow(length_y, 2) + pow(length_z, 2));

  temp_speed[leg][0] = length_x / length * move_speed * speed_multiple;
  temp_speed[leg][1] = length_y / length * move_speed * speed_multiple;
  temp_speed[leg][2] = length_z / length * move_speed * speed_multiple;

  if (x != KEEP)
    site_expect[leg][0] = x;
  if (y != KEEP)
    site_expect[leg][1] = y;
  if (z != KEEP)
    site_expect[leg][2] = z;
}

/*
  - wait one of end points move to expect site
  - blocking function
   ---------------------------------------------------------------------------*/
void wait_reach(int leg)
{
  while (1)
    if (site_now[leg][0] == site_expect[leg][0])
      if (site_now[leg][1] == site_expect[leg][1])
        if (site_now[leg][2] == site_expect[leg][2])
          break;
}

/*
  - wait all of end points move to expect site
  - blocking function
   ---------------------------------------------------------------------------*/
void wait_all_reach(void)
{
  for (int i = 0; i &lt; 4; i++)
    wait_reach(i);
}

/*
  - trans site from cartesian to polar
  - mathematical model 2/2
   ---------------------------------------------------------------------------*/
void cartesian_to_polar(volatile float &amp;alpha, volatile float &amp;beta, volatile float &amp;gamma, volatile float x, volatile float y, volatile float z)
{
  //calculate w-z degree
  float v, w;
  w = (x &gt;= 0 ? 1 : -1) * (sqrt(pow(x, 2) + pow(y, 2)));
  v = w - length_c;
  alpha = atan2(z, v) + acos((pow(length_a, 2) - pow(length_b, 2) + pow(v, 2) + pow(z, 2)) / 2 / length_a / sqrt(pow(v, 2) + pow(z, 2)));
  beta = acos((pow(length_a, 2) + pow(length_b, 2) - pow(v, 2) - pow(z, 2)) / 2 / length_a / length_b);
  //calculate x-y-z degree
  gamma = (w &gt;= 0) ? atan2(y, x) : atan2(-y, -x);
  //trans degree pi-&gt;180
  alpha = alpha / pi * 180;
  beta = beta / pi * 180;
  gamma = gamma / pi * 180;
}

/*
  - trans site from polar to microservos
  - mathematical model map to fact
  - the errors saved in eeprom will be add
   ---------------------------------------------------------------------------*/
void polar_to_servo(int leg, float alpha, float beta, float gamma)
{
  if (leg == 0)
  {
    alpha = 90 - alpha;
    beta = beta;
    gamma += 90;
  }
  else if (leg == 1)
  {
    alpha += 90;
    beta = 180 - beta;
    gamma = 90 - gamma;
  }
  else if (leg == 2)
  {
    alpha += 90;
    beta = 180 - beta;
    gamma = 90 - gamma;
  }
  else if (leg == 3)
  {
    alpha = 90 - alpha;
    beta = beta;
    gamma += 90;
  }

  servo[leg][0].write(alpha);
  servo[leg][1].write(beta);
  servo[leg][2].write(gamma);
}
</code></pre>

<h3>Passo 14: Fazer algo especial</h3>

<p>Agora podem ser acrescentadas funcionalidades ao robot, como controlo remoto, etc.</p>

<p>O autor recomenda que se partilhem as funcionalidades extra adicionadas.
Dois exemplos:</p>

<ul>
<li><a href="http://regishsu.blogspot.tw/2015/09/robot-quadruped-robot-remoter.html">Controlo Remoto</a></li>
<li><a href="http://regishsu.blogspot.tw/2015/08/robot-quadruped-robot-ir-fc-51-ir.html">Deteção de obstáculos com infra-vermelhos</a></li>
</ul>

<p>Outros artigos/projetos interessantes de ler:</p>

<ul>
<li><a href="http://www.instructables.com/id/How-to-Make-a-Bionic-Beetle-Robot/">How to Make a Bionic Beetle Robot</a></li>
<li><a href="http://www.mcafee.com/us/resources/white-papers/wp-automotive-security.pdf">Automotive Security Best Practices</a></li>
<li><a href="http://blog.freesideatlanta.org/2014/03/manual-pick-and-place-project.html">Manual Pick and Place project</a></li>
<li><a href="http://www.limpkin.fr/index.php?post/2015/08/30/A-Connected-Clock-to-Wake-Me-Up">A Connected Lamp to Wake Me Up</a></li>
<li><a href="http://blog.majormega.com/looping-piano">Building an analog looping piano</a></li>
</ul>

<hr />

<h1 id="Compras">Compras <a href="#topo">^</a></h1>

<p>Artigos do <em>ebay</em> ou de outras lojas <em>online</em> que poderão ser úteis em projetos. A informação aqui presente apenas serve para ajudar na aquisição dos componentes. O altLab não tem qualquer intervenção/participação em qualquer negócio aqui apresentado.</p>

<h2>SG90 Micro 9g Servo For RC Helicopter Hitec JR Futaba</h2>

<p>(<a href="http://www.ebay.co.uk/itm/291548877727">http://www.ebay.co.uk/itm/291548877727</a>) - £1.12</p>

<p><img src="Compras_1.jpg" alt="Compras_1" /></p>

<p>Description:
Features:</p>

<ul>
<li>TOWERPROSG-90 Micro Servo</li>
<li>All Nylon Gear</li>
<li>Connector Wire Length 150MM</li>
</ul>

<p>Specifications:</p>

<ul>
<li>Dimensions: 22<em>11.5</em>27mm</li>
<li>Operating Speed (4.8V no load): 0.12sec/60 degrees</li>
<li>Stall Torque : 1.2kg / 42.3oz(4.8V);1.6 kg / 56.4oz (6.0V)</li>
<li>Temperature Range: -30 to +60 Degree C</li>
<li>Dead Band Width: 7usec</li>
<li>Operating Voltage:3.0-7.2 Volts</li>
<li>Net weight: 14g</li>
<li>Color: blue</li>
</ul>

<p>Packing Content:</p>

<ul>
<li>1 x SG90 Servos (with Accessories )</li>
</ul>

<h2>1Pcs MP1584-ADJ Mini DC/DC Power Supply Module Adjustable Decompression Module</h2>

<p>(<a href="http://www.ebay.co.uk/itm/231555528833">http://www.ebay.co.uk/itm/231555528833</a>) - £0.99</p>

<p><img src="Compras_2.jpg" alt="Compras_2" /></p>

<p>Features:</p>

<ul>
<li>DIY mobile power, monitor power supply, power buggies, camera power supply, car power, communications equipment supply, various  right size and weight for demanding applications (such as aviation models, etc.).</li>
<li>Input voltage: 4.5-28V</li>
<li>Output Voltage: 0.8-20V (adjustable)</li>
<li>Output current: 3A(Max).</li>
<li>Switching Frequency: 1MHz</li>
<li>Efficiency:96%(max)</li>
<li>Operating temperature: Industrial grade (-40 C to +85 C)</li>
<li>Size:22<em>17</em>4mm</li>
</ul>

<p>Package Content:</p>

<ul>
<li>1x DC-DC Converter Adjustable Module replace MP1584</li>
</ul>

<h2>5pcs 5*7 Universal Double Side PCB 5x7cm DIY Prototype Paper PCB 1.6mm</h2>

<p>(<a href="http://www.ebay.co.uk/itm/231243746665">http://www.ebay.co.uk/itm/231243746665</a>) - 3.28 €</p>

<p><img src="Compras_3.jpg" alt="Compras_3" /></p>

<p>Product Name:</p>

<p>Double Side Board PCB 5x7cm 1.6mm DIY Prototype Paper PCB</p>

<h2>20x Latching 7x7mm Mini Tactile Push Button Switch On-Off DIP-6pins FST</h2>

<p>(<a href="http://www.ebay.co.uk/itm/131539414243">http://www.ebay.co.uk/itm/131539414243</a>) - £0.99</p>

<p><img src="Compras_4.jpg" alt="Compras_4" /></p>

<p>Description:</p>

<p>20x Latching 7x7mm Mini Tactile Push Button Switch On-Off DIP-6pins</p>

<p>Specifications</p>

<ul>
<li>Temperature: -40℃ ~ +70℃</li>
<li>Rated load: DC 30V 0.5A</li>
<li>Insulation resistance: ≥100MΩ</li>
<li>Contact resistance: ≤0.03Ω</li>
<li>Withstand voltage: AC 250V (50Hz)/min</li>
<li>Actuation force: 150~300G</li>
</ul>

<p>Package Includes</p>

<ul>
<li>20x Latching 7x7mm Mini Tactile Push Button Switch On-Off DIP-6pins</li>
</ul>

<hr />

<p>That's all Folks!</p>

					</div>
				</section>
				</div> <!-- Container -->

				<footer id="footer" class="panel-footer">
					<div class="inner">
						<a href="https://github.com/PhileCMS/Phile">Phile</a> was made by <a href="https://github.com/PhileCMS">The PhileCMS Community</a>.
					</div>
				</footer>
			</div>
		</div>
</div>
		<script data-cfasync="false" src="../../../../../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-20725619-1']);
            _gaq.push(['_trackPageview']);
            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
		<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.altlab.org/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
	</body>
</html>
